<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://idlebook.github.io</id><title>idlebook</title><subtitle>嗨，我是添书，一名 iOS 开发者,目前暂居深圳。</subtitle> <updated>2021-01-19T00:07:49+08:00</updated> <author> <name>idlebook</name> <uri>https://idlebook.github.io</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://idlebook.github.io" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 idlebook </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>LeetCode例题分析(五)</title><link href="https://idlebook.github.io/posts/16/" rel="alternate" type="text/html" title="LeetCode例题分析(五)" /><published>2020-03-22T00:00:00+08:00</published> <updated>2020-03-22T00:00:00+08:00</updated> <id>https://idlebook.github.io/posts/16/</id> <content src="https://idlebook.github.io/posts/16/" /> <author> <name>idlebook</name> </author> <summary> LRU缓存机制 描述 运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。   进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例: LRUCache cache = new LRUCache( 2 ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 c... </summary> </entry> <entry><title>LeetCode例题分析(四)</title><link href="https://idlebook.github.io/posts/15/" rel="alternate" type="text/html" title="LeetCode例题分析(四)" /><published>2020-03-07T00:00:00+08:00</published> <updated>2020-03-07T00:00:00+08:00</updated> <id>https://idlebook.github.io/posts/15/</id> <content src="https://idlebook.github.io/posts/15/" /> <author> <name>idlebook</name> </author> <summary> 买卖股票的最佳时机 描述 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-s... </summary> </entry> <entry><title>LeetCode例题分析(三)</title><link href="https://idlebook.github.io/posts/14/" rel="alternate" type="text/html" title="LeetCode例题分析(三)" /><published>2020-02-22T00:00:00+08:00</published> <updated>2020-02-22T00:00:00+08:00</updated> <id>https://idlebook.github.io/posts/14/</id> <content src="https://idlebook.github.io/posts/14/" /> <author> <name>idlebook</name> </author> <summary> 最大二叉树 描述 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 示例 ： 输入：[3,2,1,6,0,5] 输出：返回下面这棵树的根节点： 提示： 给定的数组的大小在 [1, 1000] 之间。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 为什么采用递归 这是属于一分二, 二分三, 三分万物的类型, 一个子问题的解逐步扩大大整个问题的解 变种题目为什么用栈可以，单调... </summary> </entry> <entry><title>LeetCode例题分析(二)</title><link href="https://idlebook.github.io/posts/13/" rel="alternate" type="text/html" title="LeetCode例题分析(二)" /><published>2020-02-16T00:00:00+08:00</published> <updated>2020-02-16T00:00:00+08:00</updated> <id>https://idlebook.github.io/posts/13/</id> <content src="https://idlebook.github.io/posts/13/" /> <author> <name>idlebook</name> </author> <summary> 最小栈 描述 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.getMin(); --&amp;gt; 返回 -2. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/... </summary> </entry> <entry><title>LeetCode例题分析(一)</title><link href="https://idlebook.github.io/posts/12/" rel="alternate" type="text/html" title="LeetCode例题分析(一)" /><published>2020-02-05T00:00:00+08:00</published> <updated>2020-02-05T00:00:00+08:00</updated> <id>https://idlebook.github.io/posts/12/</id> <content src="https://idlebook.github.io/posts/12/" /> <author> <name>idlebook</name> </author> <summary> 颜色分类 描述 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sort-colors 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 只能扫描一趟且复杂度为1,一般是双指针或者... </summary> </entry> </feed>
