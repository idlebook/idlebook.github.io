<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>面向协议编程与 Cocoa 的邂逅 (上)</title>
  <meta name="description" content="本文是笔者在 MDCC 16 (移动开发者大会) 上 iOS 专场中的主题演讲的文字整理。您可以在这里找到演讲使用的 Keynote，部分示例代码可以在 MDCC 2016 的官方 repo 中找到。因为全部内容比较长，所以分成了上下两个部分，本文 (上) 主要介绍了一些理论方面的内容，包括面向对象编程存在的问题...">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="面向协议编程与 Cocoa 的邂逅 (上)">
  <meta name="twitter:description" content="本文是笔者在 MDCC 16 (移动开发者大会) 上 iOS 专场中的主题演讲的文字整理。您可以在这里找到演讲使用的 Keynote，部分示例代码可以在 MDCC 2016 的官方 repo 中找到。因为全部内容比较长，所以分成了上下两个部分，本文 (上) 主要介绍了一些理论方面的内容，包括面向对象编程存在的问题...">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="面向协议编程与 Cocoa 的邂逅 (上)">
  <meta property="og:description" content="本文是笔者在 MDCC 16 (移动开发者大会) 上 iOS 专场中的主题演讲的文字整理。您可以在这里找到演讲使用的 Keynote，部分示例代码可以在 MDCC 2016 的官方 repo 中找到。因为全部内容比较长，所以分成了上下两个部分，本文 (上) 主要介绍了一些理论方面的内容，包括面向对象编程存在的问题...">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2016/11/pop-cocoa-1/">
  <link rel="alternate" type="application/rss+xml" title="OneV's Den" href="http://localhost:4000/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 OneV's Den 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="OneV's Den logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for OneV's Den" class="blog-button">OneV's Den</a></h1>

        
        <span class="panel-cover__subtitle panel-subtitle">上善若水，人淡如菊</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨，我是王巍 (@onevcat)，一名 iOS 开发者。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description"><a href="https://objccn.io/products/">我组织的 ObjC 中国与 objc.io 合作发布了一系列 iOS/Swift 相关图书，欢迎访问了解更多</a></p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="//onev.cat" target="_blank" title="我的简历">简历</a></li>
                
                  <li class="navigation__item"><a href="/apps" target="_blank" title="我所使用的 app 们">工具</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/onevcat" title="@onevcat 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/onevcat" title="@onevcat 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  
  <!-- Twitter -->
  <li class="navigation__item">
    <a href="http://twitter.com/onevcat" title="@onevcat" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:onev@onevcat.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-11-29 09:22:11 +0800" itemprop="datePublished" class="post-meta__date date">2016-11-29</time> &#8226; <span class="post-meta__tags tags">能工巧匠集</span>
    </div>
    <h1 class="post-title">面向协议编程与 Cocoa 的邂逅 (上)</h1>
  </header>

  <section class="post">
    <p>本文是笔者在 MDCC 16 (移动开发者大会) 上 iOS 专场中的主题演讲的文字整理。您可以在<a href="https://speakerdeck.com/onevcat/mian-xiang-xie-yi-bian-cheng-yu-cocoa-de-xie-hou">这里</a>找到演讲使用的 Keynote，部分示例代码可以在 MDCC 2016 的<a href="https://github.com/MDCC2016/ProtocolNetwork">官方 repo</a> 中找到。因为全部内容比较长，所以分成了上下两个部分，本文 (上) 主要介绍了一些理论方面的内容，包括面向对象编程存在的问题，面向协议的基本概念和决策模型等，<a href="/2016/12/pop-cocoa-2/">下半部分</a>主要展示了一些笔者日常使用面向协议思想和 Cocoa 开发结合的示例代码，并对其进行了一些解说。</p>

<h2 id="引子">引子</h2>

<p>面向协议编程 (Protocol Oriented Programming，以下简称 POP) 是 Apple 在 2015 年 WWDC 上提出的 Swift 的一种编程范式。相比与传统的面向对象编程 (OOP)，POP 显得更加灵活。结合 Swift 的值语义特性和 Swift 标准库的实现，这一年来大家发现了很多 POP 的应用场景。本次演讲希望能在介绍 POP 思想的基础上，引入一些日常开发中可以使用 POP 的场景，让与会来宾能够开始在日常工作中尝试 POP，并改善代码设计。</p>

<h2 id="起初识---什么是-swift-协议">起・初识 - 什么是 Swift 协议</h2>

<h3 id="protocol">Protocol</h3>

<p>Swift 标准库中有 50 多个复杂不一的协议，几乎所有的实际类型都是满足若干协议的。protocol 是 Swift 语言的底座，语言的其他部分正是在这个底座上组织和建立起来的。这和我们熟知的面向对象的构建方式很不一样。</p>

<p>一个最简单但是有实际用处的 Swift 协议定义如下：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Greetable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">greet</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这几行代码定义了一个名为 <code class="highlighter-rouge">Greetable</code> 的协议，其中有一个 <code class="highlighter-rouge">name</code> 属性的定义，以及一个 <code class="highlighter-rouge">greet</code> 方法的定义。</p>

<p>所谓协议，就是一组属性和/或方法的定义，而如果某个具体类型想要遵守一个协议，那它需要实现这个协议所定义的所有这些内容。协议实际上做的事情不过是“关于实现的约定”。</p>

<h3 id="面向对象">面向对象</h3>

<p>在深入 Swift 协议的概念之前，我想先重新让大家回顾一下面向对象。相信我们不论在教科书或者是博客等各种地方对这个名词都十分熟悉了。那么有一个很有意思，但是其实并不是每个程序员都想过的问题，面向对象的核心思想究竟是什么？</p>

<p>我们先来看一段面向对象的代码：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Animal</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">leg</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"eat food."</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"run with </span><span class="se">\(</span><span class="n">leg</span><span class="se">)</span><span class="s"> legs"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Tiger</span><span class="p">:</span> <span class="kt">Animal</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">var</span> <span class="nv">leg</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">4</span> <span class="p">}</span>
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"eat meat."</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">tiger</span> <span class="o">=</span> <span class="kt">Tiger</span><span class="p">()</span>
<span class="n">tiger</span><span class="o">.</span><span class="nf">eat</span><span class="p">()</span> <span class="c1">// "eat meat"</span>
<span class="n">tiger</span><span class="o">.</span><span class="nf">run</span><span class="p">()</span> <span class="c1">// "run with 4 legs"</span>
</code></pre></div></div>

<p>父类 <code class="highlighter-rouge">Animal</code> 定义了动物的 <code class="highlighter-rouge">leg</code> (这里应该使用虚类，但是 Swift 中没有这个概念，所以先请无视这里的 <code class="highlighter-rouge">return 2</code>)，以及动物的 <code class="highlighter-rouge">eat</code> 和 <code class="highlighter-rouge">run</code> 方法，并为它们提供了实现。子类的 <code class="highlighter-rouge">Tiger</code> 根据自身情况重写了 <code class="highlighter-rouge">leg</code> (4 条腿)和 <code class="highlighter-rouge">eat</code> (吃肉)，而对于 <code class="highlighter-rouge">run</code>，父类的实现已经满足需求，因此不必重写。</p>

<p>我们看到 <code class="highlighter-rouge">Tiger</code> 和 <code class="highlighter-rouge">Animal</code> 共享了一部分代码，这部分代码被封装到了父类中，而除了 <code class="highlighter-rouge">Tiger</code> 的其他的子类也能够使用 <code class="highlighter-rouge">Animal</code> 的这些代码。这其实就是 OOP 的核心思想 - 使用封装和继承，将一系列相关的内容放到一起。我们的前辈们为了能够对真实世界的对象进行建模，发展出了面向对象编程的概念，但是这套理念有一些缺陷。虽然我们努力用这套抽象和继承的方法进行建模，但是实际的事物往往是一系列<strong>特质的组合</strong>，而不单单是以一脉相承并逐渐扩展的方式构建的。所以最近大家越来越发现面向对象很多时候其实不能很好地对事物进行抽象，我们可能需要寻找另一种更好的方式。</p>

<h3 id="面向对象编程的困境">面向对象编程的困境</h3>

<h4 id="横切关注点">横切关注点</h4>

<p>我们再来看一个例子。这次让我们远离动物世界，回到 Cocoa，假设我们有一个 <code class="highlighter-rouge">ViewController</code>，它继承自 <code class="highlighter-rouge">UIViewController</code>，我们向其中添加一个 <code class="highlighter-rouge">myMethod</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ViewCotroller</span><span class="p">:</span> <span class="kt">UIViewController</span>
<span class="p">{</span>
    <span class="c1">// 继承</span>
    <span class="c1">// view, isFirstResponder()...</span>
    
    <span class="c1">// 新加</span>
    <span class="kd">func</span> <span class="nf">myMethod</span><span class="p">()</span> <span class="p">{</span>
        
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果这时候我们又有一个继承自 <code class="highlighter-rouge">UITableViewController</code> 的 <code class="highlighter-rouge">AnotherViewController</code>，我们也想向其中添加同样的 <code class="highlighter-rouge">myMethod</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">AnotherViewController</span><span class="p">:</span> <span class="kt">UITableViewController</span>
<span class="p">{</span>
    <span class="c1">// 继承</span>
    <span class="c1">// tableView, isFirstResponder()...</span>
    
    <span class="c1">// 新加</span>
    <span class="kd">func</span> <span class="nf">myMethod</span><span class="p">()</span> <span class="p">{</span>
        
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这时，我们迎来了 OOP 的第一个大困境，那就是我们很难在不同继承关系的类里共用代码。这里的问题用“行话”来说叫做“横切关注点” (Cross-Cutting Concerns)。我们的关注点 <code class="highlighter-rouge">myMethod</code> 位于两条继承链 (<code class="highlighter-rouge">UIViewController</code> -&gt; <code class="highlighter-rouge">ViewCotroller</code> 和 <code class="highlighter-rouge">UIViewController</code> -&gt; <code class="highlighter-rouge">UITableViewController</code> -&gt; <code class="highlighter-rouge">AnotherViewController</code>) 的横切面上。面向对象是一种不错的抽象方式，但是肯定不是最好的方式。它无法描述两个不同事物具有某个相同特性这一点。在这里，特性的组合要比继承更贴切事物的本质。</p>

<p>想要解决这个问题，我们有几个方案：</p>

<ul>
  <li>
    <p>Copy &amp; Paste</p>

    <p>这是一个比较糟糕的解决方案，但是演讲现场还是有不少朋友选择了这个方案，特别是在工期很紧，无暇优化的情况下。这诚然可以理解，但是这也是坏代码的开头。我们应该尽量避免这种做法。</p>
  </li>
  <li>
    <p>引入 BaseViewController</p>

    <p>在一个继承自 <code class="highlighter-rouge">UIViewController</code> 的 <code class="highlighter-rouge">BaseViewController</code> 上添加需要共享的代码，或者干脆在 <code class="highlighter-rouge">UIViewController</code> 上添加 extension。看起来这是一个稍微靠谱的做法，但是如果不断这么做，会让所谓的 <code class="highlighter-rouge">Base</code> 很快变成垃圾堆。职责不明确，任何东西都能扔进 <code class="highlighter-rouge">Base</code>，你完全不知道哪些类走了 <code class="highlighter-rouge">Base</code>，而这个“超级类”对代码的影响也会不可预估。</p>
  </li>
  <li>
    <p>依赖注入</p>

    <p>通过外界传入一个带有 <code class="highlighter-rouge">myMethod</code> 的对象，用新的类型来提供这个功能。这是一个稍好的方式，但是引入额外的依赖关系，可能也是我们不太愿意看到的。</p>
  </li>
  <li>
    <p>多继承</p>

    <p>当然，Swift 是不支持多继承的。不过如果有多继承的话，我们确实可以从多个父类进行继承，并将 <code class="highlighter-rouge">myMethod</code> 添加到合适的地方。有一些语言选择了支持多继承 (比如 C++)，但是它会带来 OOP 中另一个著名的问题：菱形缺陷。</p>
  </li>
</ul>

<h4 id="菱形缺陷">菱形缺陷</h4>

<p>上面的例子中，如果我们有多继承，那么 <code class="highlighter-rouge">ViewController</code> 和 <code class="highlighter-rouge">AnotherViewController</code> 的关系可能会是这样的：</p>

<p><img src="/assets/images/2016/diamond.png" alt="" /></p>

<p>在上面这种拓扑结构中，我们只需要在 <code class="highlighter-rouge">ViewController</code> 中实现 <code class="highlighter-rouge">myMethod</code>，在 <code class="highlighter-rouge">AnotherViewController</code> 中也就可以继承并使用它了。看起来很完美，我们避免了重复。但是多继承有一个无法回避的问题，就是两个父类都实现了同样的方法时，子类该怎么办？我们很难确定应该继承哪一个父类的方法。因为多继承的拓扑结构是一个菱形，所以这个问题又被叫做菱形缺陷 (Diamond Problem)。像是 C++ 这样的语言选择粗暴地将菱形缺陷的问题交给程序员处理，这无疑非常复杂，并且增加了人为错误的可能性。而绝大多数现代语言对多继承这个特性选择避而远之。</p>

<h4 id="动态派发安全性">动态派发安全性</h4>

<p>Objective-C 恰如其名，是一门典型的 OOP 语言，同时它继承了 Small Talk 的消息发送机制。这套机制十分灵活，是 OC 的基础思想，但是有时候相对危险。考虑下面的代码：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ViewController</span> <span class="o">*</span><span class="n">v1</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">[</span><span class="n">v1</span> <span class="nf">myMethod</span><span class="p">];</span>

<span class="n">AnotherViewController</span> <span class="o">*</span><span class="n">v2</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">[</span><span class="n">v2</span> <span class="nf">myMethod</span><span class="p">];</span>

<span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">@[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">obj</span> <span class="nf">myMethod</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们如果在 <code class="highlighter-rouge">ViewController</code> 和 <code class="highlighter-rouge">AnotherViewController</code> 中都实现了 <code class="highlighter-rouge">myMethod</code> 的话，这段代码是没有问题的。<code class="highlighter-rouge">myMethod</code> 将会被动态发送给 <code class="highlighter-rouge">array</code> 中的 <code class="highlighter-rouge">v1</code> 和 <code class="highlighter-rouge">v2</code>。但是，要是我们有一个没有实现 <code class="highlighter-rouge">myMethod</code> 的类型，会如何呢？</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSObject</span> <span class="o">*</span><span class="n">v3</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSObject</span> <span class="nf">new</span><span class="p">]</span>
<span class="c1">// v3 没有实现 `myMethod`</span>

<span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">@[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">obj</span> <span class="nf">myMethod</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Runtime error:</span>
<span class="c1">// unrecognized selector sent to instance blabla</span>
</code></pre></div></div>

<p>编译依然可以通过，但是显然，程序将在运行时崩溃。Objective-C 是不安全的，编译器默认你知道某个方法确实有实现，这是消息发送的灵活性所必须付出的代价。而在 app 开发看来，用可能的崩溃来换取灵活性，显然这个代价太大了。虽然这不是 OOP 范式的问题，但它确实在 Objective-C 时代给我们带来了切肤之痛。</p>

<h4 id="三大困境">三大困境</h4>

<p>我们可以总结一下 OOP 面临的这几个问题。</p>

<ul>
  <li>动态派发安全性</li>
  <li>横切关注点</li>
  <li>菱形缺陷</li>
</ul>

<p>首先，在 OC 中动态派发让我们承担了在运行时才发现错误的风险，这很有可能是发生在上线产品中的错误。其次，横切关注点让我们难以对对象进行完美的建模，代码的重用也会更加糟糕。</p>

<h2 id="承相知---协议扩展和面向协议编程">承・相知 - 协议扩展和面向协议编程</h2>

<h3 id="使用协议解决-oop-困境">使用协议解决 OOP 困境</h3>

<p>协议并不是什么新东西，也不是 Swift 的发明。在 Java 和 C# 里，它叫做 <code class="highlighter-rouge">Interface</code>。而 Swift 中的 protocol 将这个概念继承了下来，并发扬光大。让我们回到一开始定义的那个简单协议，并尝试着实现这个协议：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Greetable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">greet</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Person</span><span class="p">:</span> <span class="kt">Greetable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">func</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"你好 </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Wei Wang"</span><span class="p">)</span><span class="o">.</span><span class="nf">greet</span><span class="p">()</span>
</code></pre></div></div>

<p>实现很简单，<code class="highlighter-rouge">Person</code> 结构体通过实现 <code class="highlighter-rouge">name</code> 和 <code class="highlighter-rouge">greet</code> 来满足 <code class="highlighter-rouge">Greetable</code>。在调用时，我们就可以使用 <code class="highlighter-rouge">Greetable</code> 中定义的方法了。</p>

<h4 id="动态派发安全性-1">动态派发安全性</h4>

<p>除了 <code class="highlighter-rouge">Person</code>，其他类型也可以实现 <code class="highlighter-rouge">Greetable</code>，比如 <code class="highlighter-rouge">Cat</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Cat</span><span class="p">:</span> <span class="kt">Greetable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">func</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"meow~ </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在，我们就可以将协议作为标准类型，来对方法调用进行动态派发了：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">Greetable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
		<span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Wei Wang"</span><span class="p">),</span> 
		<span class="kt">Cat</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"onevcat"</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">array</span> <span class="p">{</span>
	<span class="n">obj</span><span class="o">.</span><span class="nf">greet</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// 你好 Wei Wang</span>
<span class="c1">// meow~ onevcat</span>
</code></pre></div></div>

<p>对于没有实现 Greetbale 的类型，编译器将返回错误，因此不存在消息误发送的情况：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Bug</span><span class="p">:</span> <span class="kt">Greetable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="c1">// Compiler Error: </span>
<span class="c1">// 'Bug' does not conform to protocol 'Greetable'</span>
<span class="c1">// protocol requires function 'greet()'</span>
</code></pre></div></div>

<p>这样一来，动态派发安全性的问题迎刃而解。如果你保持在 Swift 的世界里，那这个你的所有代码都是安全的。</p>

<ul>
  <li>✅ 动态派发安全性</li>
  <li>横切关注点</li>
  <li>菱形缺陷</li>
</ul>

<h4 id="横切关注点-1">横切关注点</h4>

<p>使用协议和协议扩展，我们可以很好地共享代码。回到上一节的 <code class="highlighter-rouge">myMethod</code> 方法，我们来看看如何使用协议来搞定它。首先，我们可以定义一个含有 <code class="highlighter-rouge">myMethod</code> 的协议：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">P</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">myMethod</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意这个协议没有提供任何的实现。我们依然需要在实际类型遵守这个协议的时候为它提供具体的实现：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// class ViewController: UIViewController</span>
<span class="kd">extension</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">myMethod</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">doWork</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// class AnotherViewController: UITableViewController</span>
<span class="kd">extension</span> <span class="kt">AnotherViewController</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">myMethod</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">doWork</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>你可能不禁要问，这和 Copy &amp; Paste 的解决方式有何不同？没错，答案就是 – 没有不同。不过稍安勿躁，我们还有其他科技可以解决这个问题，那就是协议扩展。协议本身并不是很强大，只是静态类型语言的编译器保证，在很多静态语言中也有类似的概念。那到底是什么让 Swift 成为了一门协议优先的语言？真正使协议发生质变，并让大家如此关注的原因，其实是在 WWDC 2015 和 Swift 2 发布时，Apple 为协议引入了一个新特性，协议扩展，它为 Swift 语言带来了一次革命性的变化。</p>

<p>所谓协议扩展，就是我们可以为一个协议提供默认的实现。对于 <code class="highlighter-rouge">P</code>，可以在 <code class="highlighter-rouge">extension P</code> 中为 <code class="highlighter-rouge">myMethod</code> 添加一个实现：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">P</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">myMethod</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">P</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">myMethod</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">doWork</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>有了这个协议扩展后，我们只需要简单地声明 <code class="highlighter-rouge">ViewController</code> 和 <code class="highlighter-rouge">AnotherViewController</code> 遵守 <code class="highlighter-rouge">P</code>，就可以直接使用 <code class="highlighter-rouge">myMethod</code> 的实现了：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">extension</span> <span class="kt">AnotherViewController</span><span class="p">:</span> <span class="kt">P</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">viewController</span><span class="o">.</span><span class="nf">myMethod</span><span class="p">()</span>
<span class="n">anotherViewController</span><span class="o">.</span><span class="nf">myMethod</span><span class="p">()</span>
</code></pre></div></div>

<p>不仅如此，除了已经定义过的方法，我们甚至可以在扩展中添加协议里没有定义过的方法。在这些额外的方法中，我们可以依赖协议定义过的方法进行操作。我们之后会看到更多的例子。总结下来：</p>

<ul>
  <li>协议定义
    <ul>
      <li>提供实现的入口</li>
      <li>遵循协议的类型需要对其进行实现</li>
    </ul>
  </li>
  <li>协议扩展
    <ul>
      <li>为入口提供默认实现</li>
      <li>根据入口提供额外实现</li>
    </ul>
  </li>
</ul>

<p>这样一来，横切点关注的问题也简单安全地得到了解决。</p>

<ul>
  <li>✅ 动态派发安全性</li>
  <li>✅ 横切关注点</li>
  <li>菱形缺陷</li>
</ul>

<h4 id="菱形缺陷-1">菱形缺陷</h4>

<p>最后我们看看多继承。多继承中存在的一个重要问题是菱形缺陷，也就是子类无法确定使用哪个父类的方法。在协议的对应方面，这个问题虽然依然存在，但却是可以唯一安全地确定的。我们来看一个多个协议中出现同名元素的例子：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Nameable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="k">var</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果有一个类型，需要同时实现两个协议的话，它<strong>必须</strong>提供一个 <code class="highlighter-rouge">name</code> 属性，来<strong>同时</strong>满足两个协议的要求：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Person</span><span class="p">:</span> <span class="kt">Nameable</span><span class="p">,</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> 
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="c1">// `name` 属性同时满足 Nameable 和 Identifiable 的 name</span>
</code></pre></div></div>

<p>这里比较有意思，又有点让人困惑的是，如果我们为其中的某个协议进行了扩展，在其中提供了默认的 <code class="highlighter-rouge">name</code> 实现，会如何。考虑下面的代码：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Nameable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"default name"</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">Person</span><span class="p">:</span> <span class="kt">Nameable</span><span class="p">,</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="c1">// let name: String </span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="c1">// Identifiable 也将使用 Nameable extension 中的 name</span>
</code></pre></div></div>

<p>这样的编译是可以通过的，虽然 <code class="highlighter-rouge">Person</code> 中没有定义 <code class="highlighter-rouge">name</code>，但是通过 <code class="highlighter-rouge">Nameable</code> 的 <code class="highlighter-rouge">name</code> (因为它是静态派发的)，<code class="highlighter-rouge">Person</code> 依然可以遵守 <code class="highlighter-rouge">Identifiable</code>。不过，当 <code class="highlighter-rouge">Nameable</code> 和 <code class="highlighter-rouge">Identifiable</code> 都有 <code class="highlighter-rouge">name</code> 的协议扩展的话，就无法编译了：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Nameable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"default name"</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"another default name"</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">Person</span><span class="p">:</span> <span class="kt">Nameable</span><span class="p">,</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="c1">// let name: String </span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="c1">// 无法编译，name 属性冲突</span>
</code></pre></div></div>

<p>这种情况下，<code class="highlighter-rouge">Person</code> 无法确定要使用哪个协议扩展中 <code class="highlighter-rouge">name</code> 的定义。在同时实现两个含有同名元素的协议，<strong>并且</strong>它们都提供了默认扩展时，我们需要在具体的类型中明确地提供实现。这里我们将 <code class="highlighter-rouge">Person</code> 中的 <code class="highlighter-rouge">name</code> 进行实现就可以了：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Nameable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"default name"</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"another default name"</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">Person</span><span class="p">:</span> <span class="kt">Nameable</span><span class="p">,</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> 
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"onevcat"</span><span class="p">,</span> <span class="nv">id</span><span class="p">:</span> <span class="mi">123</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="c1">// onevcat</span>
</code></pre></div></div>

<p>这里的行为看起来和菱形问题很像，但是有一些本质不同。首先，这个问题出现的前提条件是同名元素<strong>以及</strong>同时提供了实现，而协议扩展对于协议本身来说并不是必须的。其次，我们在具体类型中提供的实现一定是安全和确定的。当然，菱形缺陷没有被完全解决，Swift 还不能很好地处理多个协议的冲突，这是 Swift 现在的不足。</p>

<ul>
  <li>✅ 动态派发安全性</li>
  <li>✅ 横切关注点</li>
  <li>❓菱形缺陷</li>
</ul>

<p><a href="/2016/12/pop-cocoa-2/">本文的下半部分</a>将展示一些笔者日常使用面向协议思想和 Cocoa 开发结合的示例代码，并对其进行了一些解说。</p>


  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list post-list__post-title post-title"><a href="/2016/12/pop-cocoa-2/" title="link to 面向协议编程与 Cocoa 的邂逅 (下)">面向协议编程与 Cocoa 的邂逅 (下)</a></h2>
       <p class="excerpt">本文是笔者在 MDCC 16 (移动开发者大会) 上 iOS 专场中的主题演讲的文字整理。您可以在这里找到演讲使用的 Keynote，部分示例代码可以在 MDCC 2016 的官方 repo 中找到。在上半部分主要介绍了一些理论方面的内容，包括面向对象编程存在的问题，面向协议的基本概念和决策模型等。本文 (下) 主要展示了一些笔者日常使用面向协议思想和 Cocoa 开发结合的示例代码，并对其进行了一些解说。转・热恋 - 在日常开发中使用协议WWDC 2015 在 POP 方面有一个非常优秀...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-12-01 10:22:11 +0800" class="post-list__meta--date date">2016-12-01</time> &#8226; <span class="post-list__meta--tags tags">能工巧匠集</span><a class="btn-border-small" href=/2016/12/pop-cocoa-2/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list post-list__post-title post-title"><a href="/2016/08/notification/" title="link to 活久见的重构 - iOS 10 UserNotifications 框架解析">活久见的重构 - iOS 10 UserNotifications 框架解析</a></h2>
       <p class="excerpt">TL;DRiOS 10 中以前杂乱的和通知相关的 API 都被统一了，现在开发者可以使用独立的 UserNotifications.framework 来集中管理和使用 iOS 系统中通知的功能。在此基础上，Apple 还增加了撤回单条通知，更新已展示通知，中途修改通知内容，在通知中展示图片视频，自定义通知 UI 等一系列新功能，非常强大。对于开发者来说，相较于之前版本，iOS 10 提供了一套非常易用的通知处理接口，是 SDK 的一次重大重构。而之前的绝大部分通知相关 API 都已经被标...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-08-08 09:22:11 +0800" class="post-list__meta--date date">2016-08-08</time> &#8226; <span class="post-list__meta--tags tags">能工巧匠集</span><a class="btn-border-small" href=/2016/08/notification/>继续阅读</a></div>
   </div>
   
</section>



            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2020-05-14 生成</span>
        <span class="footer__copyright">本站由 <a href="https://onev.cat">@onevcat</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2020</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>



<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-25719337-1', 'onevcat.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
