<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>SwiftUI 的一些初步探索 (一)</title>
  <meta name="description" content="">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="SwiftUI 的一些初步探索 (一)">
  <meta name="twitter:description" content="">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="SwiftUI 的一些初步探索 (一)">
  <meta property="og:description" content="">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2019/06/swift-ui-firstlook/">
  <link rel="alternate" type="application/rss+xml" title="OneV's Den" href="http://localhost:4000/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 OneV's Den 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="OneV's Den logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for OneV's Den" class="blog-button">OneV's Den</a></h1>

        
        <span class="panel-cover__subtitle panel-subtitle">上善若水，人淡如菊</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨，我是王巍 (@onevcat)，一名 iOS 开发者。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description"><a href="https://objccn.io/products/">我组织的 ObjC 中国与 objc.io 合作发布了一系列 iOS/Swift 相关图书，欢迎访问了解更多</a></p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="//onev.cat" target="_blank" title="我的简历">简历</a></li>
                
                  <li class="navigation__item"><a href="/apps" target="_blank" title="我所使用的 app 们">工具</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/onevcat" title="@onevcat 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/onevcat" title="@onevcat 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  
  <!-- Twitter -->
  <li class="navigation__item">
    <a href="http://twitter.com/onevcat" title="@onevcat" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:onev@onevcat.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2019-06-04 14:32:00 +0800" itemprop="datePublished" class="post-meta__date date">2019-06-04</time> &#8226; <span class="post-meta__tags tags">能工巧匠集</span>
    </div>
    <h1 class="post-title">SwiftUI 的一些初步探索 (一)</h1>
  </header>

  <section class="post">
    <p><img src="/assets/images/2019/swift-ui.png" alt="" /></p>

<blockquote>
  <p>我已经计划写一本关于 SwiftUI 和 Combine 编程的书籍，希望能通过一些实践案例帮助您快速上手 SwiftUI 及 Combine 响应式编程框架，掌握下一代客户端 UI 开发技术。现在这本书已经开始预售，预计能在 10 月左右完成。如果您对此有兴趣，可以查看 <a href="https://objccn.io/products/">ObjC 中国的产品页面</a>了解详情及购买。十分感谢！</p>
</blockquote>

<h2 id="总览">总览</h2>

<p>如果你想要入门 SwiftUI 的使用，那 Apple 这次给出的<a href="https://developer.apple.com/tutorials/swiftui">官方教程</a>绝对给力。这个教程提供了非常详尽的步骤和说明，网页的交互也是一流，是觉得值得看和动手学习的参考。</p>

<p>不过，SwiftUI 中有一些值得注意的细节在教程里并没有太详细提及，也可能造成一些困惑。这篇文章以我的个人观点对教程的某些部分进行了补充说明，希望能在大家跟随教程学习 SwiftUI 的时候有点帮助。这篇文章的推荐阅读方式是，一边参照 SwiftUI 教程实际动手进行实现，一边在到达对应步骤时参照本文加深理解。在下面每段内容前我标注了对应的教程章节和链接，以供参考。</p>

<p>在开始学习 SwiftUI 之前，我们需要大致了解一个问题：为什么我们会需要一个新的 UI 框架。</p>

<h2 id="为什么需要-swiftui">为什么需要 SwiftUI</h2>

<h3 id="uikit-面临的挑战">UIKit 面临的挑战</h3>

<p>对于 Swift 开发者来说，昨天的 WWDC 19 首日 Keynote 和 Platforms State of the Union 上最引人注目的内容自然是 SwiftUI 的公布了。从 iOS SDK 2.0 开始，UIKit 已经伴随广大 iOS 开发者经历了接近十年的风风雨雨。UIKit 的思想继承了成熟的 AppKit 和 MVC，在初出时，为 iOS 开发者提供了良好的学习曲线。</p>

<p>UIKit 提供的是一套符合直觉的，基于控制流的命令式的编程方式。最主要的思想是在确保 View 或者 View Controller 生命周期以及用户交互时，相应的方法 (比如 <code class="highlighter-rouge">viewDidLoad</code> 或者某个 target-action 等) 能够被正确调用，从而构建用户界面和逻辑。不过，不管是从使用的便利性还是稳定性来说，UIKit 都面临着巨大的挑战。我个人勉强也能算是 iOS 开发的“老司机”了，但是「掉到 UIKit 的坑里」这件事，也几乎还是我每天的日常。UIKit 的基本思想要求 View Controller 承担绝大部分职责，它需要协调 model，view 以及用户交互。这带来了巨大的 side effect 以及大量的状态，如果没有妥善安置，它们将在 View Controller 中混杂在一起，同时作用于 view 或者逻辑，从而使状态管理愈发复杂，最后甚至不可维护而导致项目失败。不仅是作为开发者我们自己写的代码，UIKit 本身内部其实也经常受困于可变状态，各种奇怪的 bug 也频频出现。</p>

<h3 id="声明式的界面开发方式">声明式的界面开发方式</h3>

<p>近年来，随着编程技术和思想的进步，使用声明式或者函数式的方式来进行界面开发，已经越来越被接受并逐渐成为主流。最早的思想大概是来源于 <a href="https://elm-lang.org">Elm</a>，之后这套方式被 <a href="https://reactjs.org">React</a> 和 <a href="https://flutter.dev">Flutter</a> 采用，这一点上 SwiftUI 也几乎与它们一致。总结起来，这些 UI 框架都遵循以下步骤和原则：</p>

<ol>
  <li>
    <p>使用各自的 DSL 来描述「UI 应该是什么样子」，而不是用一句句的代码来指导「要怎样构建 UI」。</p>

    <p>比如传统的 UIKit，我们会使用这样的代码来添加一个 “Hello World” 的标签，它负责“创建 label”，“设置文字”，“将其添加到 view 上”：</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
     <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="kt">UILabel</span><span class="p">()</span>
     <span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"Hello World"</span>
     <span class="n">view</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
     <span class="c1">// 省略了布局的代码</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>而相对起来，使用 SwiftUI 我们只需要告诉 SDK 我们需要一个文字标签：</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
     <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">)</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>接下来，框架内部读取这些 view 的声明，负责将它们以合适的方式绘制渲染。</p>

    <p>注意，这些 view 的声明只是纯数据结构的描述，而不是实际显示出来的视图，因此这些结构的创建和差分对比并不会带来太多性能损耗。相对来说，将描述性的语言进行渲染绘制的部分是最慢的，这部分工作将交由框架以黑盒的方式为我们完成。</p>
  </li>
  <li>
    <p>如果 <code class="highlighter-rouge">View</code> 需要根据某个状态 (state) 进行改变，那我们将这个状态存储在变量中，并在声明 view 时使用它：</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">@State</span> <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Tom"</span>
 <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
     <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <blockquote>
      <p>关于代码细节可以先忽略，我们稍后会更多地解释这方面的内容。</p>
    </blockquote>
  </li>
  <li>
    <p>状态发生改变时，框架重新调用声明部分的代码，计算出新的 view 声明，并和原来的 view 进行差分，之后框架负责对变更的部分进行高效的重新绘制。</p>
  </li>
</ol>

<p>SwiftUI 的思想也完全一样，而且实际处理也不外乎这几个步骤。使用描述方式开发，大幅减少了在 app 开发者层面上出现问题的机率。</p>

<h2 id="一些细节解读">一些细节解读</h2>

<p><a href="https://developer.apple.com/tutorials/swiftui">官方教程</a>中对声明式 UI 的编程思想有深刻的体现。另外，SwiftUI 中也采用了非常多 Swift 5.1 的新特性，会让习惯了 Swift 4 或者 5 的开发者“耳目一新”。接下来，我会分几个话题，对官方教程的一些地方进行解释和探索。</p>

<h3 id="教程-1---creating-and-combining-views"><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">教程 1 - Creating and Combining Views</a></h3>

<h4 id="section-1---step-3-swiftui-app-的启动"><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-new-project-and-explore-the-canvas">Section 1 - Step 3: SwiftUI app 的启动</a></h4>

<p>创建 app 之后第一件好奇的事情是，SwiftUI app 是怎么启动的。</p>

<p>教程示例 app 在 AppDelegate 中通过 <code class="highlighter-rouge">application(_:configurationForConnecting:options)</code> 返回了一个名为 “Default Configuration” 的 <code class="highlighter-rouge">UISceneConfiguration</code> 实例：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">application</span><span class="p">(</span>
    <span class="n">_</span> <span class="nv">application</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span>
    <span class="n">configurationForConnecting</span> <span class="nv">connectingSceneSession</span><span class="p">:</span> <span class="kt">UISceneSession</span><span class="p">,</span>
    <span class="nv">options</span><span class="p">:</span> <span class="kt">UIScene</span><span class="o">.</span><span class="kt">ConnectionOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UISceneConfiguration</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="kt">UISceneConfiguration</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Default Configuration"</span><span class="p">,</span> <span class="nv">sessionRole</span><span class="p">:</span> <span class="n">connectingSceneSession</span><span class="o">.</span><span class="n">role</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个名字的 Configuration 在 Info.plist 的 “UIApplicationSceneManifest -&gt; UISceneConfigurations” 中进行了定义，指定了 Scene Session Delegate 类为 <code class="highlighter-rouge">$(PRODUCT_MODULE_NAME).SceneDelegate</code>。这部分内容是 iOS 13 中新加入的通过 Scene 管理 app 生命周期的方式，以及多窗口支持部分所需要的代码。这部分不是我们今天的话题。在 app 完成启动后，控制权被交接给 <code class="highlighter-rouge">SceneDelegate</code>，它的 <code class="highlighter-rouge">scene(_:willConnectTo:options:)</code> 将会被调用，进行 UI 的配置：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">scene</span><span class="p">(</span>
        <span class="n">_</span> <span class="nv">scene</span><span class="p">:</span> <span class="kt">UIScene</span><span class="p">,</span>
        <span class="n">willConnectTo</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">UISceneSession</span><span class="p">,</span>
        <span class="n">options</span> <span class="nv">connectionOptions</span><span class="p">:</span> <span class="kt">UIScene</span><span class="o">.</span><span class="kt">ConnectionOptions</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="nv">window</span> <span class="o">=</span> <span class="kt">UIWindow</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="kt">UIScreen</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">window</span><span class="o">.</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="kt">UIHostingController</span><span class="p">(</span><span class="nv">rootView</span><span class="p">:</span> <span class="kt">ContentView</span><span class="p">())</span>
        <span class="k">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span>
        <span class="n">window</span><span class="o">.</span><span class="nf">makeKeyAndVisible</span><span class="p">()</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>这部分内容就是标准的 iOS app 启动流程了。<code class="highlighter-rouge">UIHostingController</code> 是一个 <code class="highlighter-rouge">UIViewController</code> 子类，它将负责接受一个 SwiftUI 的 View 描述并将其用 UIKit 进行渲染 (在 iOS 下的情况)。<code class="highlighter-rouge">UIHostingController</code> 就是一个普通的 <code class="highlighter-rouge">UIViewController</code>，因此完全可以做到将 SwiftUI 创建的界面一点点集成到已有的 UIKit app 中，而并不需要从头开始就是基于 SwiftUI 的构建。</p>

<p>由于 Swift ABI 已经稳定，SwiftUI 是一个搭载在用户 iOS 系统上的 Swift 框架。因此它的最低支持的版本是 iOS 13，可能想要在实际项目中使用，还需要等待一两年时间。</p>

<h4 id="section-1---step-4-关于-some-view"><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-new-project-and-explore-the-canvas">Section 1 - Step 4: 关于 some View</a></h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>一眼看上去可能会对 <code class="highlighter-rouge">some</code> 比较陌生，为了讲明白这件事，我们先从 <code class="highlighter-rouge">View</code> 说起。</p>

<p><code class="highlighter-rouge">View</code> 是 SwiftUI 的一个最核心的协议，代表了一个屏幕上元素的描述。这个协议中含有一个 associatedtype：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">View</span> <span class="p">:</span> <span class="n">_View</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">Body</span> <span class="p">:</span> <span class="kt">View</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="kt">Body</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这种带有 associatedtype 的协议不能作为<strong>类型</strong>来使用，而只能作为<strong>类型约束</strong>使用：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Error</span>
<span class="kd">func</span> <span class="nf">createView</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">View</span> <span class="p">{</span>

<span class="p">}</span>

<span class="c1">// OK</span>
<span class="kd">func</span> <span class="n">createView</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">View</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
    
<span class="p">}</span>
</code></pre></div></div>

<p>这样一来，其实我们是不能写类似这种代码的：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Error，含有 associatedtype 的 protocol View 只能作为类型约束使用</span>
<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>想要 Swift 帮助自动推断出 <code class="highlighter-rouge">View.Body</code> 的类型的话，我们需要明确地指出 <code class="highlighter-rouge">body</code> 的真正的类型。在这里，<code class="highlighter-rouge">body</code> 的实际类型是 <code class="highlighter-rouge">Text</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kt">Text</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当然我们可以明确指定出 <code class="highlighter-rouge">body</code> 的类型，但是这带来一些麻烦：</p>

<ol>
  <li>每次修改 <code class="highlighter-rouge">body</code> 的返回时我们都需要手动去更改相应的类型。</li>
  <li>新建一个 <code class="highlighter-rouge">View</code> 的时候，我们都需要去考虑会是什么类型。</li>
  <li>其实我们只关心返回的是不是一个 <code class="highlighter-rouge">View</code>，而对实际上它是什么类型并不感兴趣。</li>
</ol>

<p><code class="highlighter-rouge">some View</code> 这种写法使用了 Swift 5.1 的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md">Opaque return types 特性</a>。它向编译器作出保证，每次 <code class="highlighter-rouge">body</code> 得到的一定是某一个确定的，遵守 <code class="highlighter-rouge">View</code> 协议的类型，但是请编译器“网开一面”，不要再细究具体的类型。返回类型<strong>确定单一</strong>这个条件十分重要，比如，下面的代码也是无法通过的：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">let</span> <span class="nv">someCondition</span><span class="p">:</span> <span class="kt">Bool</span>

<span class="c1">// Error: Function declares an opaque return type, </span>
<span class="c1">// but the return statements in its body do not have </span>
<span class="c1">// matching underlying types.</span>
<span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">someCondition</span> <span class="p">{</span>
        <span class="c1">// 这个分支返回 Text</span>
        <span class="k">return</span> <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 这个分支返回 Button，和 if 分支的类型不统一</span>
        <span class="k">return</span> <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{})</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Tap me"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这是一个编译期间的特性，在保证 associatedtype protocol 的功能的前提下，使用 <code class="highlighter-rouge">some</code> 可以抹消具体的类型。这个特性用在 SwiftUI 上简化了书写难度，让不同 <code class="highlighter-rouge">View</code> 声明的语法上更加统一。</p>

<h4 id="section-2---step-1-预览-swiftui"><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#customize-the-text-view">Section 2 - Step 1: 预览 SwiftUI</a></h4>

<p>SwiftUI 的 Preview 是 Apple 用来对标 RN 或者 Flutter 的 Hot Reloading 的开发工具。由于 IBDesignable 的性能上的惨痛教训，而且得益于 SwiftUI 经由 UIKit 的跨 Apple 平台的特性，Apple 这次选择了直接在 macOS 上进行渲染。因此，你需要使用搭载有 SwiftUI.framework 的 macOS 10.15 才能够看到 Xcode Previews 界面。</p>

<p>Xcode 将对代码进行静态分析 (得益于 <a href="https://github.com/apple/swift-syntax">SwiftSyntax 框架</a>)，找到所有遵守 <code class="highlighter-rouge">PreviewProvider</code> 协议的类型进行预览渲染。另外，你可以为这些预览提供合适的数据，这甚至可以让整个界面开发流程不需要实际运行 app 就能进行。</p>

<p>笔者自己尝试下来，这套开发方式带来的效率提升相比 Hot Reloading 要更大。Hot Reloading 需要你有一个大致界面和准备相应数据，然后运行 app，停在要开发的界面，再进行调整。如果数据状态发生变化，你还需要 restart app 才能反应。SwiftUI 的 Preview 相比起来，不需要运行 app 并且可以提供任何的 dummy 数据，在开发效率上更胜一筹。</p>

<p>经过短短一天的使用，Option + Command + P 这个刷新 preview 的快捷键已经深入到我的肌肉记忆中了。</p>

<h4 id="section-3---step-5-关于-viewbuilder"><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#combine-views-using-stacks">Section 3 - Step 5: 关于 ViewBuilder</a></h4>

<p>创建 Stack 的语法很有趣：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">VStack</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">Text</span><span class="p">(</span><span class="s">"Turtle Rock"</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>
    <span class="kt">Text</span><span class="p">(</span><span class="s">"Joshua Tree National Park"</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">subheadline</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>一开始看起来好像我们给出了两个 <code class="highlighter-rouge">Text</code>，似乎是构成的是一个类似数组形式的 <code class="highlighter-rouge">[View]</code>，但实际上并不是这么一回事。这里调用了 <code class="highlighter-rouge">VStack</code> 类型的初始化方法：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">VStack</span><span class="o">&lt;</span><span class="kt">Content</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">Content</span> <span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span>
        <span class="nv">alignment</span><span class="p">:</span> <span class="kt">HorizontalAlignment</span> <span class="o">=</span> <span class="o">.</span><span class="n">center</span><span class="p">,</span> 
        <span class="nv">spacing</span><span class="p">:</span> <span class="kt">Length</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">,</span> 
        <span class="nv">content</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Content</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>前面的 <code class="highlighter-rouge">alignment</code> 和 <code class="highlighter-rouge">spacing</code> 没啥好说，最后一个 <code class="highlighter-rouge">content</code> 比较有意思。看签名的话，它是一个 <code class="highlighter-rouge">() -&gt; Content</code> 类型，但是我们在创建这个 <code class="highlighter-rouge">VStack</code> 时所提供的代码只是简单列举了两个 <code class="highlighter-rouge">Text</code>，而并没有实际返回一个可用的 <code class="highlighter-rouge">Content</code>。</p>

<p>这里使用了 Swift 5.1 的另一个新特性：<a href="https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md">Funtion builders</a>。如果你实际观察 <code class="highlighter-rouge">VStack</code> 的<a href="https://developer.apple.com/documentation/swiftui/vstack/3278367-init">这个初始化方法的签名</a>，会发现 <code class="highlighter-rouge">content</code> 前面其实有一个 <code class="highlighter-rouge">@ViewBuilder</code> 标记：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">init</span><span class="p">(</span>
    <span class="nv">alignment</span><span class="p">:</span> <span class="kt">HorizontalAlignment</span> <span class="o">=</span> <span class="o">.</span><span class="n">center</span><span class="p">,</span> 
    <span class="nv">spacing</span><span class="p">:</span> <span class="kt">Length</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">,</span> 
    <span class="kd">@ViewBuilder</span> <span class="nv">content</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Content</span><span class="p">)</span>
</code></pre></div></div>

<p>而 <code class="highlighter-rouge">ViewBuilder</code> 则是一个由 <code class="highlighter-rouge">@_functionBuilder</code> 进行标记的 struct：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@_functionBuilder</span> <span class="kd">public</span> <span class="kd">struct</span> <span class="kt">ViewBuilder</span> <span class="p">{</span> <span class="cm">/* */</span> <span class="p">}</span>
</code></pre></div></div>

<p>使用 <code class="highlighter-rouge">@_functionBuilder</code> 进行标记的类型 (这里的 <code class="highlighter-rouge">ViewBuilder</code>)，可以被用来对其他内容进行标记 (这里用 <code class="highlighter-rouge">@ViewBuilder</code> 对 <code class="highlighter-rouge">content</code> 进行标记)。被用 function builder 标记过的 <code class="highlighter-rouge">ViewBuilder</code> 标记以后，<code class="highlighter-rouge">content</code> 这个输入的 function 在被使用前，会按照 <code class="highlighter-rouge">ViewBuilder</code> 中合适的 <code class="highlighter-rouge">buildBlock</code> <a href="https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md#function-building-methods">进行 build</a> 后再使用。如果你阅读 <code class="highlighter-rouge">ViewBuilder</code> 的<a href="https://developer.apple.com/documentation/swiftui/viewbuilder">文档</a>，会发现有很多接受不同个数参数的 <code class="highlighter-rouge">buildBlock</code> 方法，它们将负责把闭包中一一列举的 <code class="highlighter-rouge">Text</code> 和其他可能的 <code class="highlighter-rouge">View</code> 转换为一个 <code class="highlighter-rouge">TupleView</code>，并返回。由此，<code class="highlighter-rouge">content</code> 的签名 <code class="highlighter-rouge">() -&gt; Content</code> 可以得到满足。</p>

<p>实际上构建这个 <code class="highlighter-rouge">VStack</code> 的代码会被转换为类似下面这样：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 等效伪代码，不能实际编译。</span>
<span class="kt">VStack</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">)</span> <span class="p">{</span> <span class="n">viewBuilder</span> <span class="o">-&gt;</span> <span class="kt">Content</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">text1</span> <span class="o">=</span> <span class="kt">Text</span><span class="p">(</span><span class="s">"Turtle Rock"</span><span class="p">)</span><span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">text2</span> <span class="o">=</span> <span class="kt">Text</span><span class="p">(</span><span class="s">"Joshua Tree National Park"</span><span class="p">)</span><span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">subheadline</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">viewBuilder</span><span class="o">.</span><span class="nf">buildBlock</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当然这种基于 funtion builder 的方式是有一定限制的。比如 <code class="highlighter-rouge">ViewBuilder</code> 就只实现了最多<a href="https://developer.apple.com/documentation/swiftui/viewbuilder/3278693-buildblock">十个参数</a>的 <code class="highlighter-rouge">buildBlock</code>，因此如果你在一个 <code class="highlighter-rouge">VStack</code> 中放超过十个 <code class="highlighter-rouge">View</code> 的话，编译器就会不太高兴。不过对于正常的 UI 构建，十个参数应该足够了。如果还不行的话，你也可以考虑直接使用 <code class="highlighter-rouge">TupleView</code> 来用多元组的方式合并 <code class="highlighter-rouge">View</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">TupleView</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">Text</span><span class="p">,</span> <span class="kt">Text</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="p">(</span><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">),</span> <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">))</span>
<span class="p">)</span>
</code></pre></div></div>

<p>除了按顺序接受和构建 <code class="highlighter-rouge">View</code> 的 <code class="highlighter-rouge">buildBlock</code> 以外，<code class="highlighter-rouge">ViewBuilder</code> 还实现了两个特殊的方法：<code class="highlighter-rouge">buildEither</code> 和 <code class="highlighter-rouge">buildIf</code>。它们分别对应 block 中的 <code class="highlighter-rouge">if...else</code> 的语法和 <code class="highlighter-rouge">if</code> 的语法。也就是说，你可以在 <code class="highlighter-rouge">VStack</code> 里写这样的代码：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">someCondition</span><span class="p">:</span> <span class="kt">Bool</span>

<span class="kt">VStack</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">Text</span><span class="p">(</span><span class="s">"Turtle Rock"</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>
    <span class="kt">Text</span><span class="p">(</span><span class="s">"Joshua Tree National Park"</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">subheadline</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">someCondition</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"Condition"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"Not Condition"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其他的命令式的代码在 <code class="highlighter-rouge">VStack</code> 的 <code class="highlighter-rouge">content</code> 闭包里是不被接受的，下面这样也不行：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">VStack</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">leading</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// let 语句无法通过 function builder 创建合适的输出</span>
    <span class="k">let</span> <span class="nv">someCondition</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">condition</span>
    <span class="k">if</span> <span class="n">someCondition</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"Condition"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"Not Condition"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>到目前为止，只有以下三种写法能被接受 (有可能随着 SwiftUI 的发展出现别的可接受写法)：</p>

<ul>
  <li>结果为 <code class="highlighter-rouge">View</code> 的语句</li>
  <li><code class="highlighter-rouge">if</code> 语句</li>
  <li><code class="highlighter-rouge">if...else...</code> 语句</li>
</ul>

<h4 id="section-4---step-7-链式调用修改-view-的属性"><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-custom-image-view">Section 4 - Step 7: 链式调用修改 View 的属性</a></h4>

<p>教程到这一步的话，相信大家已经对 SwiftUI 的超强表达能力有所感悟了。</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">Image</span><span class="p">(</span><span class="s">"turtlerock"</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">clipShape</span><span class="p">(</span><span class="kt">Circle</span><span class="p">())</span>
        <span class="o">.</span><span class="nf">overlay</span><span class="p">(</span>
            <span class="kt">Circle</span><span class="p">()</span><span class="o">.</span><span class="nf">stroke</span><span class="p">(</span><span class="kt">Color</span><span class="o">.</span><span class="n">white</span><span class="p">,</span> <span class="nv">lineWidth</span><span class="p">:</span> <span class="mi">4</span><span class="p">))</span>
        <span class="o">.</span><span class="nf">shadow</span><span class="p">(</span><span class="nv">radius</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以试想一下，在 UIKit 中要动手撸一个这个效果的困难程度。我大概可以保证，99% 的开发者很难在不借助文档或者 copy paste 的前提下完成这些事情，但是在 SwiftUI 中简直信手拈来。在创建 <code class="highlighter-rouge">View</code> 之后，用链式调用的方式，可以将 <code class="highlighter-rouge">View</code> 转换为一个含有变更后内容的对象。这么说比较抽象，我们可以来看一个具体的例子。比如简化一下上面的代码：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">image</span><span class="p">:</span> <span class="kt">Image</span> <span class="o">=</span> <span class="kt">Image</span><span class="p">(</span><span class="s">"turtlerock"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">modified</span><span class="p">:</span> <span class="n">_ModifiedContent</span><span class="o">&lt;</span><span class="kt">Image</span><span class="p">,</span> <span class="n">_ShadowEffect</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="nf">shadow</span><span class="p">(</span><span class="nv">radius</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">image</code> 通过一个 <code class="highlighter-rouge">.shadow</code> 的 modifier，<code class="highlighter-rouge">modified</code> 变量的类型将转变为 <code class="highlighter-rouge">_ModifiedContent&lt;Image, _ShadowEffect&gt;</code>。如果你查看 <code class="highlighter-rouge">View</code> 上的 <code class="highlighter-rouge">shadow</code> 的定义，它是这样的：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">shadow</span><span class="p">(</span>
        <span class="nv">color</span><span class="p">:</span> <span class="kt">Color</span> <span class="o">=</span> <span class="kt">Color</span><span class="p">(</span><span class="o">.</span><span class="n">sRGBLinear</span><span class="p">,</span> <span class="nv">white</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">opacity</span><span class="p">:</span> <span class="mf">0.33</span><span class="p">),</span> 
        <span class="nv">radius</span><span class="p">:</span> <span class="kt">Length</span><span class="p">,</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> 
    <span class="o">-&gt;</span> <span class="k">Self</span><span class="o">.</span><span class="kt">Modified</span><span class="o">&lt;</span><span class="n">_ShadowEffect</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Modified</code> 是 <code class="highlighter-rouge">View</code> 上的一个 typealias，在 <code class="highlighter-rouge">struct Image: View</code> 的实现里，我们有：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">typealias</span> <span class="kt">Modified</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">_ModifiedContent</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="kt">T</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">_ModifiedContent</code> 是一个 SwiftUI 的私有类型，它存储了待变更的内容，以及用来实施变更的 <code class="highlighter-rouge">Modifier</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="n">_ModifiedContent</span><span class="o">&lt;</span><span class="kt">Content</span><span class="p">,</span> <span class="kt">Modifier</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">content</span><span class="p">:</span> <span class="kt">Content</span>
    <span class="k">var</span> <span class="nv">modifier</span><span class="p">:</span> <span class="kt">Modifier</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">Content</code> 遵守 <code class="highlighter-rouge">View</code>，<code class="highlighter-rouge">Modifier</code> 遵守 <code class="highlighter-rouge">ViewModifier</code> 的情况下，<code class="highlighter-rouge">_ModifiedContent</code> 也将遵守 <code class="highlighter-rouge">View</code>，这是我们能够通过 <code class="highlighter-rouge">View</code> 的各个 modifier extension 进行链式调用的基础：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="nv">_ModifiedContent</span> <span class="p">:</span> <span class="n">_View</span> 
    <span class="k">where</span> <span class="kt">Content</span> <span class="p">:</span> <span class="kt">View</span><span class="p">,</span> <span class="kt">Modifier</span> <span class="p">:</span> <span class="kt">ViewModifier</span> 
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">shadow</code> 的例子中，SwiftUI 内部会使用 <code class="highlighter-rouge">_ShadowEffect</code> 这个 <code class="highlighter-rouge">ViewModifier</code>，并把 <code class="highlighter-rouge">image</code> 自身和 <code class="highlighter-rouge">_ShadowEffect</code> 实例存放到 <code class="highlighter-rouge">_ModifiedContent</code> 里。不论是 image 还是 modifier，都只是对未来实际视图的描述，而不是直接对渲染进行的操作。在最终渲染前，<code class="highlighter-rouge">ViewModifier</code> 的 <code class="highlighter-rouge">body(content: Self.Content) -&gt; Self.Body</code> 将被调用，以给出最终渲染层所需要的各个属性。</p>

<blockquote>
  <p>更具体来说，<code class="highlighter-rouge">_ShadowEffect</code> 是一个满足 <a href="https://developer.apple.com/documentation/swiftui/environmentalmodifier"><code class="highlighter-rouge">EnvironmentalModifier</code> 协议</a>的类型，这个协议要求在使用前根据使用环境将自身解析为具体的 modifier。</p>
</blockquote>

<p>其他的几个修改 View 属性的链式调用与 <code class="highlighter-rouge">shadow</code> 的原理几乎一致。</p>

<h2 id="小结">小结</h2>

<p>上面是对 SwiftUI 教程的第一部分进行的一些说明，在之后的一篇文章里，我会对剩余的几个教程中有意思的部分再做些解释。</p>

<p>虽然公开还只有一天，但是 SwiftUI 已经经常被用来和 Flutter 等框架进行比较。试用下来，在 view 的描述表现力上和与 app 的结合方面，SwiftUI 要胜过 Flutter 和 Dart 的组合很多。Swift 虽然开源了，但是 Apple 对它的掌控并没有减弱。Swift 5.1 的很多特性几乎可以说都是为了 SwiftUI 量身定制的，我们已经在本文中看到了一些例子，比如 Opaque return types 和 Function builder 等。在接下来对后面几个教程的解读中，我们还会看到更多这方面的内容。</p>

<p>另外，Apple 在背后使用 Combine.framework 这个响应式编程框架来对 SwiftUI.framework 进行驱动和数据绑定，相比于现有的 RxSwift/RxCocoa 或者是 ReactiveSwift 的方案来说，得到了语言和编译器层级的大力支持。如果有机会，我想我也会对这方面的内容进行一些探索和介绍。</p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list post-list__post-title post-title"><a href="/2019/06/swift-ui-firstlook-2/" title="link to SwiftUI 的一些初步探索 (二)">SwiftUI 的一些初步探索 (二)</a></h2>
       <p class="excerpt">  我已经计划写一本关于 SwiftUI 和 Combine 编程的书籍，希望能通过一些实践案例帮助您快速上手 SwiftUI 及 Combine 响应式编程框架，掌握下一代客户端 UI 开发技术。现在这本书已经开始预售，预计能在 10 月左右完成。如果您对此有兴趣，可以查看 ObjC 中国的产品页面了解详情及购买。十分感谢！接上一篇继续对 SwiftUI 的教程进行一些解读。教程 2 - Building Lists and NavigationSection 4 - Step 2: 静...&hellip;</p>
       <div class="post-list__meta"><time datetime="2019-06-11 11:32:00 +0800" class="post-list__meta--date date">2019-06-11</time> &#8226; <span class="post-list__meta--tags tags">能工巧匠集</span><a class="btn-border-small" href=/2019/06/swift-ui-firstlook-2/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list post-list__post-title post-title"><a href="/2019/02/swift-abi/" title="link to Swift ABI 稳定对我们到底意味着什么">Swift ABI 稳定对我们到底意味着什么</a></h2>
       <p class="excerpt">Swift 社区最近最重大的新闻应该就是 ABI 稳定了。这个话题虽然已经讨论了有一阵子了，但随着 Xcode 10.2 beta 的迭代和 Swift 5 的 release 被提上日程，最终 Swift ABI 稳定能做到什么程度，我们开发者能做些什么，需要做些什么，就变成了一个重要的话题。Apple 在这个月接连发布了 ABI Stability and More 和 Evolving Swift On Apple Platforms After ABI Stability 两篇文章...&hellip;</p>
       <div class="post-list__meta"><time datetime="2019-02-21 09:28:00 +0800" class="post-list__meta--date date">2019-02-21</time> &#8226; <span class="post-list__meta--tags tags">能工巧匠集</span><a class="btn-border-small" href=/2019/02/swift-abi/>继续阅读</a></div>
   </div>
   
</section>



            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2020-05-14 生成</span>
        <span class="footer__copyright">本站由 <a href="https://onev.cat">@onevcat</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2020</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>



<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-25719337-1', 'onevcat.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
