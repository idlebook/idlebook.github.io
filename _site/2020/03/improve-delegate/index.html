<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>使用 protocol 和 callAsFunction 改进 Delegate</title>
  <meta name="description" content="2018 年 3 月的时候我写过一篇在 Swift 中如何改进 Delegate Pattern 的文章，主要思想是用遮蔽变量 (shadow variable) 声明的方式，来保证 self 变量可以被常时地标记为 weak。本文中，为了保证没有看过原文的读者能处在同一频道，我会先 (再次) 简单介绍一下这种方...">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="使用 protocol 和 callAsFunction 改进 Delegate">
  <meta name="twitter:description" content="2018 年 3 月的时候我写过一篇在 Swift 中如何改进 Delegate Pattern 的文章，主要思想是用遮蔽变量 (shadow variable) 声明的方式，来保证 self 变量可以被常时地标记为 weak。本文中，为了保证没有看过原文的读者能处在同一频道，我会先 (再次) 简单介绍一下这种方...">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="使用 protocol 和 callAsFunction 改进 Delegate">
  <meta property="og:description" content="2018 年 3 月的时候我写过一篇在 Swift 中如何改进 Delegate Pattern 的文章，主要思想是用遮蔽变量 (shadow variable) 声明的方式，来保证 self 变量可以被常时地标记为 weak。本文中，为了保证没有看过原文的读者能处在同一频道，我会先 (再次) 简单介绍一下这种方...">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2020/03/improve-delegate/">
  <link rel="alternate" type="application/rss+xml" title="OneV's Den" href="http://localhost:4000/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 OneV's Den 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="OneV's Den logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for OneV's Den" class="blog-button">OneV's Den</a></h1>

        
        <span class="panel-cover__subtitle panel-subtitle">上善若水，人淡如菊</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨，我是王巍 (@onevcat)，一名 iOS 开发者。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description"><a href="https://objccn.io/products/">我组织的 ObjC 中国与 objc.io 合作发布了一系列 iOS/Swift 相关图书，欢迎访问了解更多</a></p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="//onev.cat" target="_blank" title="我的简历">简历</a></li>
                
                  <li class="navigation__item"><a href="/apps" target="_blank" title="我所使用的 app 们">工具</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/onevcat" title="@onevcat 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/onevcat" title="@onevcat 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  
  <!-- Twitter -->
  <li class="navigation__item">
    <a href="http://twitter.com/onevcat" title="@onevcat" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:onev@onevcat.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2020-03-12 09:00:00 +0800" itemprop="datePublished" class="post-meta__date date">2020-03-12</time> &#8226; <span class="post-meta__tags tags">能工巧匠集</span>
    </div>
    <h1 class="post-title">使用 protocol 和 callAsFunction 改进 Delegate</h1>
  </header>

  <section class="post">
    <p>2018 年 3 月的时候我写过一篇在 Swift 中如何<a href="https://xiaozhuanlan.com/topic/6104325798">改进 Delegate Pattern</a> 的文章，主要思想是用遮蔽变量 (shadow variable) 声明的方式，来保证 <code class="highlighter-rouge">self</code> 变量可以被常时地标记为 <code class="highlighter-rouge">weak</code>。本文中，为了保证没有看过原文的读者能处在同一频道，我会先 (再次) 简单介绍一下这种方法。然后，结合 Swift 5.2 的新特性提出一些小的改进方式。</p>

<h2 id="delegate">Delegate</h2>

<p>简单说，为了避免繁琐老式的 <code class="highlighter-rouge">protocol</code> 定义和实现，我们可能更倾向于选择提供闭包的方式完成回调。比如在一个收集用户输入的自定义 view 中，提供一个外部可以设置的函数类型变量 <code class="highlighter-rouge">onConfirmInput</code>，并在合适的时候调用它：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">TextInputView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">inputTextField</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">onConfirmInput</span><span class="p">:</span> <span class="p">((</span><span class="kt">String</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span>

    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">confirmButtonPressed</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">Any</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">onConfirmInput</span><span class="p">?(</span><span class="n">inputTextField</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">TextInputView</code> 的 controller 中，检测 input 确定事件就不需要一堆 <code class="highlighter-rouge">textInputView.delegate = self</code> 和 <code class="highlighter-rouge">textInputView(_:didConfirmText:)</code> 之类 的麻烦事了，可以直接设置 <code class="highlighter-rouge">onConfirmInput</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">textLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">inputView</span> <span class="o">=</span> <span class="kt">TextInputView</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="cm">/*...*/</span><span class="p">)</span>
        <span class="n">inputView</span><span class="o">.</span><span class="n">onConfirmInput</span> <span class="o">=</span> <span class="p">{</span> <span class="n">text</span> <span class="k">in</span> 
            <span class="k">self</span><span class="o">.</span><span class="n">textLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
        <span class="p">}</span>
        <span class="n">view</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="n">inputView</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是这引入了一个 retain cycle！<code class="highlighter-rouge">TextInputView.onConfirmInput</code> 持有 <code class="highlighter-rouge">self</code>，而 <code class="highlighter-rouge">self</code> 通过 <code class="highlighter-rouge">view</code> 持有 <code class="highlighter-rouge">TextInputView</code> 这个 sub view，内存将会无法释放。</p>

<p>当然，解决方法也很简单，我们只需要在设置 <code class="highlighter-rouge">onConfirmInput</code> 的时候使用 <code class="highlighter-rouge">[weak self]</code> 来将闭包中的 <code class="highlighter-rouge">self</code> 换为弱引用即可：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inputView</span><span class="o">.</span><span class="n">onConfirmInput</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">text</span> <span class="k">in</span>
    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">textLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这为使用 <code class="highlighter-rouge">onConfirmInput</code> 这样的闭包变量加上了一个前提：你大概率需要将 <code class="highlighter-rouge">self</code> 标记为 <code class="highlighter-rouge">weak</code> 以避免犯错，否则你将写出一个内存泄漏。这个泄漏无法在编译期间定位，运行时也不会有任何警告或者错误，这类问题也极易带到最终产品中。在开发界有一句话是真理：</p>

<blockquote>
  <p>如果一个问题可能发生，那么它必然会发生。</p>
</blockquote>

<p>一个简单的 <code class="highlighter-rouge">Delegate</code> 类型可以解决这个问题：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Delegate</span><span class="o">&lt;</span><span class="kt">Input</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">block</span><span class="p">:</span> <span class="p">((</span><span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span><span class="p">?)?</span>
    <span class="kd">func</span> <span class="n">delegate</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="o">&gt;</span><span class="p">(</span><span class="n">on</span> <span class="nv">target</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span> <span class="nv">block</span><span class="p">:</span> <span class="p">((</span><span class="kt">T</span><span class="p">,</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span><span class="p">)?)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="n">target</span><span class="p">]</span> <span class="n">input</span> <span class="k">in</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">target</span> <span class="o">=</span> <span class="n">target</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
            <span class="k">return</span> <span class="nf">block</span><span class="p">?(</span><span class="n">target</span><span class="p">,</span> <span class="n">input</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">call</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">block</span><span class="p">?(</span><span class="n">input</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>通过设置 <code class="highlighter-rouge">block</code> 时就将 <code class="highlighter-rouge">target</code> (通常是 <code class="highlighter-rouge">self</code>) 做 <code class="highlighter-rouge">weak</code> 化处理，并且在调用 <code class="highlighter-rouge">block</code> 时提供一个 weak 后的 <code class="highlighter-rouge">target</code> 的变量，就可以保证在调用侧不会意外地持有 <code class="highlighter-rouge">target</code>。举个例子，上面的 <code class="highlighter-rouge">TextInputView</code> 可以重写为：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">TextInputView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">let</span> <span class="nv">onConfirmInput</span> <span class="o">=</span> <span class="kt">Delegate</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">?,</span> <span class="kt">Void</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">confirmButtonPressed</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">Any</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">onConfirmInput</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">inputTextField</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用时，通过 <code class="highlighter-rouge">delegate(on:)</code> 完成订阅：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inputView</span><span class="o">.</span><span class="n">onConfirmInput</span><span class="o">.</span><span class="nf">delegate</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="n">textLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
<span class="p">}</span>
</code></pre></div></div>

<p>闭包的输入参数 <code class="highlighter-rouge">(self, text)</code> 和闭包 body <code class="highlighter-rouge">self.textLabel.text</code> 中的 <code class="highlighter-rouge">self</code>，<strong>并不是</strong>原来的代表 controller 的 self，而是由 <code class="highlighter-rouge">Delegate</code> 把 <code class="highlighter-rouge">self</code> 标为 <code class="highlighter-rouge">weak</code> 后的参数。因此，直接在闭包中使用这个遮蔽变量 <code class="highlighter-rouge">self</code>，也不会造成循环引用。</p>

<p>到这里为止的原始版本 <code class="highlighter-rouge">Delegate</code> 可以在<a href="https://gist.github.com/onevcat/3c8f7c4e8c96f288854688cf34111636/3674c944a420a09f473726043856f28c9c1014d0">这个 Gist</a> 里找到，加上空行一共就 21 行代码。</p>

<h2 id="问题和改进">问题和改进</h2>

<p>上面的实现有三个小瑕疵，我们对它们进行一些分析和改进。</p>

<h3 id="1-更自然i的调用">1. 更自然i的调用</h3>

<p>现在，对 delegate 的调用时不如闭包变量那样自然，每次需要去使用 <code class="highlighter-rouge">call(_:)</code> 或者 <code class="highlighter-rouge">call()</code>。虽然不是什么大不了的事情，但是如果能直接使用类似 <code class="highlighter-rouge">onConfirmInput(inputTextField.text)</code> 的形式，会更简单。</p>

<p>Swift 5.2 中引入的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md"><code class="highlighter-rouge">callAsFunction</code></a>，它可以让我们直接以“调用实例”的方式 call 一个方法。使用起来很简单，只需要创建一个名称为 <code class="highlighter-rouge">callAsFunction</code> 的实例方法就可以了：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Adder</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">callAsFunction</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">input</span> <span class="o">+</span> <span class="n">value</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">add2</span> <span class="o">=</span> <span class="kt">Adder</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="nf">add2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// 3</span>
</code></pre></div></div>

<p>这个特性非常适合把 <code class="highlighter-rouge">Delegate.call</code> 简化，只需要加入对应的 <code class="highlighter-rouge">callAsFunction</code> 实现，并调用 <code class="highlighter-rouge">block</code> 就行了：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">Delegate</span><span class="o">&lt;</span><span class="kt">Input</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    
    <span class="kd">func</span> <span class="nf">callAsFunction</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">block</span><span class="p">?(</span><span class="n">input</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">TextInputView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">confirmButtonPressed</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">Any</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">onConfirmInput</span><span class="p">(</span><span class="n">inputTextField</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在，<code class="highlighter-rouge">onConfirmInput</code> 的调用看起来就和一个闭包完全一样了。</p>

<blockquote>
  <p>类似于 <code class="highlighter-rouge">callAsFunction</code> 的直接在实例上调用方法的方式，在 Python 中有很多应用。在 Swift 语言中添加这个特性能让习惯于 Python 的开发者更容易地迁移到像是 Swift for TensorFlow 这样的项目。而这个提案的提出和审核相关人员，也基本是 Swift for TensorFlow 的成员。</p>
</blockquote>

<h3 id="2-双层可选值">2. 双层可选值</h3>

<p>如果 <code class="highlighter-rouge">Delegate&lt;Input, Output&gt;</code> 中的 <code class="highlighter-rouge">Output</code> 是一个可选值的话，那么 <code class="highlighter-rouge">call</code> 之后的结果将会是双重可选的 <code class="highlighter-rouge">Output??</code>。</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">onReturnOptional</span> <span class="o">=</span> <span class="kt">Delegate</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">?</span><span class="o">&gt;</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="n">onReturnOptional</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// value : Int??</span>
</code></pre></div></div>

<p>这可以让我们区分出 <code class="highlighter-rouge">block</code> 没有被设置的情况和 <code class="highlighter-rouge">Delegate</code> 确实返回 <code class="highlighter-rouge">nil</code> 的情况：当 <code class="highlighter-rouge">onReturnOptional.delegate(on:block:)</code> 没有被调用过 (<code class="highlighter-rouge">block</code> 为 <code class="highlighter-rouge">nil</code>) 时，<code class="highlighter-rouge">value</code> 是简单的 <code class="highlighter-rouge">nil</code>。但如果 <code class="highlighter-rouge">delegate</code> 被设置了，但是闭包返回的是 <code class="highlighter-rouge">nil</code> 时，<code class="highlighter-rouge">value</code> 的值将为 <code class="highlighter-rouge">.some(nil)</code>。在实际使用上这很容易造成困惑，绝大多数情况下，我们希望把 <code class="highlighter-rouge">.none</code>，<code class="highlighter-rouge">.some(.none)</code> 和 <code class="highlighter-rouge">.some(.some(value))</code> 这样的返回值展平到单层 <code class="highlighter-rouge">Optional</code> 的 <code class="highlighter-rouge">.none</code> 或 <code class="highlighter-rouge">.some(value)</code>。</p>

<p>要解决这个问题，可以对 <code class="highlighter-rouge">Delegate</code> 进行扩展，为那些 <code class="highlighter-rouge">Output</code> 是 <code class="highlighter-rouge">Optional</code> 情况提供重载的 <code class="highlighter-rouge">call(_:)</code> 实现。不过 <code class="highlighter-rouge">Optional</code> 是带有泛型参数的类型，所以我们没有办法写出像是 
<code class="highlighter-rouge">extension Delegate where Output == Optional</code> 这样的条件扩展。一个“取巧”的方式是自定义一个新的 <code class="highlighter-rouge">OptionalProtocol</code>，让 <code class="highlighter-rouge">extension</code> 基于 <code class="highlighter-rouge">where Output: OptionalProtocol</code> 来做条件扩展：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">OptionalProtocol</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">createNil</span><span class="p">:</span> <span class="k">Self</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Optional</span> <span class="p">:</span> <span class="kt">OptionalProtocol</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">var</span> <span class="nv">createNil</span><span class="p">:</span> <span class="kt">Optional</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span> <span class="p">{</span>
         <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Delegate</span> <span class="k">where</span> <span class="kt">Output</span><span class="p">:</span> <span class="kt">OptionalProtocol</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">call</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="nf">block</span><span class="p">?(</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">.</span><span class="n">createNil</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样，即使 <code class="highlighter-rouge">Output</code> 为可选值，<code class="highlighter-rouge">block?(input)</code> 调用所得到的结果也可以经过 <code class="highlighter-rouge">if let</code> 解包，并返回单层的 <code class="highlighter-rouge">result</code> 或是 <code class="highlighter-rouge">nil</code>。</p>

<h3 id="3-遮蔽失效">3. 遮蔽失效</h3>

<p>由于使用了遮蔽变量 <code class="highlighter-rouge">self</code>，在闭包中的 <code class="highlighter-rouge">self</code> 其实是这个遮蔽变量，而非原本的 <code class="highlighter-rouge">self</code>。这样要求我们比较小心，否则可能造成意外的循环引用。比如下面的例子：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inputView</span><span class="o">.</span><span class="n">onConfirmInput</span><span class="o">.</span><span class="nf">delegate</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="n">textLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的代码编译和使用都没有问题，但是由于我们把 <code class="highlighter-rouge">(self, text)</code> 换成了 <code class="highlighter-rouge">(_, text)</code>，这导致闭包内部 <code class="highlighter-rouge">self.textLabel.text</code> 中的 <code class="highlighter-rouge">self</code> 直接参照了真正的 <code class="highlighter-rouge">self</code>，这是一个强引用，进而内存泄露。</p>

<p>这种错误和 <code class="highlighter-rouge">[weak self]</code> 声明一样，没有办法得到编译器的提示，所以也很难完全避免。也许一个可行方案是不要用 <code class="highlighter-rouge">(self, text)</code> 这样的隐式遮蔽，而是将参数名明确写成不一样的形式，比如 <code class="highlighter-rouge">(weakSelf, text)</code>，然后在闭包中只使用 <code class="highlighter-rouge">weakSelf</code>。但这么做其实和 <code class="highlighter-rouge">self</code> 遮蔽差距不大，依然摆脱不了用“人为规定”来强制统一代码规则。当然，你也可以依靠使用 linter 和添加对应规则来提醒自己，但是这些方式也都不是非常理想。如果你有什么好的想法或者建议，十分欢迎交流和指教。</p>

  </section>
</article>

<section class="read-more">
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list post-list__post-title post-title"><a href="/2020/01/customize-publisher/" title="link to 在 Combine 中实现自定义 Publisher">在 Combine 中实现自定义 Publisher</a></h2>
       <p class="excerpt">  本文是对我的《SwiftUI 和 Combine 编程》书籍的补充，对一些虽然很重要，但和书中上下文内容相去略远，或者一些不太适合以书本的篇幅详细展开解释的内容进行了追加说明。如果你对 SwiftUI 和 Combine 的更多话题有兴趣的话，可以考虑参阅原书。上一篇文章里，我们探索了 Combine 里对 back pressure 的处理。在那边，主要涉及到的是实现自定义的 Subscriber，来通过控制事件流终端的 pull 行为，实现合理的 back pressure 机制。...&hellip;</p>
       <div class="post-list__meta"><time datetime="2020-01-20 09:00:00 +0800" class="post-list__meta--date date">2020-01-20</time> &#8226; <span class="post-list__meta--tags tags">能工巧匠集</span><a class="btn-border-small" href=/2020/01/customize-publisher/>继续阅读</a></div>
   </div>
   
</section>



            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2020-05-14 生成</span>
        <span class="footer__copyright">本站由 <a href="https://onev.cat">@onevcat</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2020</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>



<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-25719337-1', 'onevcat.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
