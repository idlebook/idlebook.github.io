[ { "title": "LeetCode例题分析(五)", "url": "/posts/16/", "categories": "", "tags": "算法", "date": "2020-03-22 00:00:00 +0800", "snippet": "LRU缓存机制描述运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？示例:LRUCache cache = ne..." }, { "title": "LeetCode例题分析(四)", "url": "/posts/15/", "categories": "", "tags": "算法", "date": "2020-03-07 00:00:00 +0800", "snippet": "买卖股票的最佳时机描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。注意：你不能在买入股票前卖出股票。示例 1:输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。示例 2:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, ..." }, { "title": "LeetCode例题分析(三)", "url": "/posts/14/", "categories": "", "tags": "算法", "date": "2020-02-22 00:00:00 +0800", "snippet": "最大二叉树描述给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：二叉树的根是数组中的最大元素。左子树是通过数组中最大值左边部分构造出的最大二叉树。右子树是通过数组中最大值右边部分构造出的最大二叉树。通过给定的数组构建最大二叉树，并且输出这个树的根节点。示例 ：输入：[3,2,1,6,0,5]输出：返回下面这棵树的根节点：提示：给定的数组的大小在 [1, 1000] 之间。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注..." }, { "title": "LeetCode例题分析(二)", "url": "/posts/13/", "categories": "", "tags": "算法", "date": "2020-02-16 00:00:00 +0800", "snippet": "最小栈描述设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。示例:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&amp;gt; 返回 -3.minStack.pop();minStack.top(); --&amp;gt; 返回..." }, { "title": "LeetCode例题分析(一)", "url": "/posts/12/", "categories": "", "tags": "算法", "date": "2020-02-05 00:00:00 +0800", "snippet": "颜色分类描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。注意:不能使用代码库中的排序函数来解决这道题。示例:输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2]进阶：一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？来源：力扣（LeetCode）链接：https://leetcode-cn.com/..." }, { "title": "密码学的一些探索之公钥证书", "url": "/posts/11/", "categories": "", "tags": "能工巧匠集", "date": "2019-08-10 00:00:00 +0800", "snippet": "一、为什么需要公钥证书？在上一篇文章中我们谈到了数字签名，数字签名可以识别篡改或者发送者身份是否被伪装，也就是验证消息的完整性，还可以对消息进行认证。还可以防止抵赖。看似一切完美，但是他的弱点也在他的优点上，数字签名需要用公钥来确认发送者的身份。我们需要从一个没有被伪装的发送者那里得到没有被篡改的公钥才行，为了验证得到的公钥是否合法，必须使用公钥证书。证书是将公钥当做一条消息，由一个可信的第三方对其签名后所得到的公钥。二、什么是公钥证书？公钥证书(Public-Key Certificate，PKC)记录着个人信息(姓名、组织、邮箱地址等个人信息)和个人公钥，并由认证机构(Certifi..." }, { "title": "密码学的一些探索之数字签名", "url": "/posts/10/", "categories": "", "tags": "能工巧匠集", "date": "2019-08-02 00:00:00 +0800", "snippet": "一、为什么需要数字签名？从上一篇文章里面我们知道，消息认证码可以识别篡改或者发送者身份是否被伪装，也就是验证消息的完整性，还可以对消息进行认证。但是消息认证码的缺陷就在于它的共享密钥上面。由于共享密钥的原因，导致无法防止抵赖。数字签名就是为了解决抵赖的问题的。解决的方法就是让通信双方的共享密钥不同，从密钥上能区分出谁是谁。二、什么是数字签名？数字签名相当于现实世界中的盖章、签名的功能在计算机世界中进行实现的技术。数字签名可以识别篡改、伪装、防止抵赖。在数字签名中，有 2 种行为： 生成消息签名的行为 验证消息签名的行为生成消息签名的人是由消息发送者完成的，也称为“对消息签名”。生成签..." }, { "title": "密码学的一些探索之消息认证码", "url": "/posts/18/", "categories": "", "tags": "能工巧匠集", "date": "2019-07-26 00:00:00 +0800", "snippet": "一、为什么需要消息认证码？还是举一个银行汇钱的例子：A 向 B 汇钱 100 万元。如果攻击者从中攻击，篡改这条消息，就可能变成 A 向攻击者汇钱 1000 万元。这里针对汇款消息，需要注意两个问题：消息的 “完整性” 和 “认证” 。消息的完整性，就叫消息的一致性，这个可以用上一篇文章中讲的消息指纹来判断，通过对比单向散列函数的 hash 值来判断这条消息的完整性，有没有被篡改。消息的认证，指的是，消息是否来自正确的发送者。如果确认汇款请求确实来自 A，就相当于对消息进行了认证，代表消息没有被伪装。如果同时需要识别出篡改和伪装，即要确认消息的完整性，又要对消息进行认证，这种情况下就需要..." }, { "title": "谈谈Websocket,QQ, 微信,这类IMApp应该怎么做", "url": "/posts/17/", "categories": "", "tags": "能工巧匠集", "date": "2019-03-05 00:00:00 +0800", "snippet": " 目录 1.WebSocket使用场景 2.WebSocket诞生由来 3.谈谈WebSocket协议原理 4.WebSocket 和 Socket的区别与联系 5.iOS平台有哪些WebSocket和Socket的开源框架 6.iOS平台如何实现WebSocket协议一.WebSocket的使用场景1.社交聊天最著名的就是微信，QQ，这一类社交聊天的app。这一类聊天app的特点是低延迟，高即时。即时是这里面要求最高的，如果有一个紧急的事情，通过IM软件通知你，假设网络环境良好的情况下，这条message还无法立即送达到你的客户端上，紧急的事情都结束了，你才收到消息，那么这..." }, { "title": "谈谈iOS的一些优化点", "url": "/posts/007/", "categories": "", "tags": "能工巧匠集", "date": "2018-10-15 00:00:00 +0800", "snippet": "性能优化卡顿优化 CPU CPU（Central Processing Unit，中央处理器） 对象的创建和销毁 对象属性的调 布局计算 文本的计算和排版 图片的格式转换和解码 图像的绘制（Core Graphics GPU GPU（Graphics Processing Unit，图形处理器） 纹理的渲染 屏幕成像原理 卡顿产生的原因 CPU 和 GPU 在绘制一帧..." }, { "title": "底层原理之内存管理", "url": "/posts/006/", "categories": "", "tags": "能工巧匠集", "date": "2018-09-20 00:00:00 +0800", "snippet": "CADisplayLink、NSTimer使用注意 CADisplayLink、NSTimer会对target产生强引用，如果target又对它们产生强引用，那么就会引发循环引用定时器解决方案 利用block的弱指针捕获特性,然而CADisplayLink并没有block方法 不可以使用的方法,把weakSelf传入target中,原因:传入的对象是形参,内部实参target内部还是对当前对象进行强引用(实参/形参本质还是内存地址) 采取中间对象的方式处理(消息转发应用场景之一) 分析,当pop时候,由于没有强指针指向..." }, { "title": "底层原理之动态运行时", "url": "/posts/005/", "categories": "", "tags": "能工巧匠集", "date": "2018-09-12 00:00:00 +0800", "snippet": "RunTime Objective-C是一门动态性比较强的编程语言，跟C、C++等语言有着很大的不同 Objective-C的动态性是由Runtime API来支撑的 Runtime API提供的接口基本都是C语言的，源码由C\\C++\\汇编语言编写####isa详解 要想学习Runtime，首先要了解它底层的一些常用数据结构，比如isa指针 在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址 从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息 ..." }, { "title": "底层原理之再论Block", "url": "/posts/004/", "categories": "", "tags": "能工巧匠集", "date": "2018-09-05 00:00:00 +0800", "snippet": "block的本质 block的数据结构 struct __main_block_desc_0 { size_t reserved; size_t Block_size;};struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int a..." }, { "title": "Mac命令行科学上网", "url": "/posts/003/", "categories": "", "tags": "能工巧匠集", "date": "2017-10-03 00:00:00 +0800", "snippet": "Mac命令行科学上网 因为终端只支持socks5代理,不像科学上网走http通道 所以,基础配置好了科学上网工具,开启了全局模式,依旧没有在命令行生效 这样,对于码农来讲,wget、curl、git、brew等命令行工具都会变得很慢。 解决方式是socks代理转http通道. 因为苹果在新系统中加入了SIP安全机制，他会阻止第三方程序向系统目录内（/System，/bin，/sbin，/usr(除了/usr/local)）进行写操作，sudo也不行。办法是先把SIP关了，等装好软件配置好后再打开SIP。或者改用其他软件,proxychains-NG等软件就不太好搞了 第一种工..." }, { "title": "iOS组件化探索之路(实践篇)", "url": "/posts/001/", "categories": "", "tags": "能工巧匠集", "date": "2017-06-10 00:00:00 +0800", "snippet": "iOS组件化探索之路(实践篇) 上篇主要讲了组件化的一些基本概念和解决方案,然而没有实践的支撑并没有什么卵用,本篇以图文的形式详细讲解组件化的步骤以及探索过程中的各种解决方法的对比.知识储备 组件化的基础是建立在cocoapods和git管理之上,但是并不需要很深入地了解才能进行组件化,本文对于必要的操作进行一个简单的介绍 git的相关操作 基本概念 工作区→ 与.git文件夹同级的其他文件夹或者子文件夹 版本控制库 暂缓区 分支 ..." }, { "title": "iOS组件化探索之路(理论篇)", "url": "/posts/002/", "categories": "", "tags": "能工巧匠集", "date": "2017-06-07 00:00:00 +0800", "snippet": "iOS组件化探索之路(理论篇) 随着应用需求逐步迭代，应用的代码体积将会越来越大，为了更好的管理应用工程，我们开始借助CocoaPods版本管理工具对原有应用工程进行拆分。 但是仅仅完成代码拆分还不足以解决业务之间的代码耦合，为了更好的让拆分出去的业务工程能够独立运行，必须进行组件拆分并且实现组件服务化。 什么是组件化 将一个单一工程的项目, 分解成为各个独立的组件; 然后按照某种方式, 任意组织成一个拥有完整业务逻辑的工程 为什么需要组件化 如果是单一工程, 业务线比较少, 人数比较少, 一般的开发模式没有任何问题 但是一旦项目发展慢慢庞大, ..." } ]
