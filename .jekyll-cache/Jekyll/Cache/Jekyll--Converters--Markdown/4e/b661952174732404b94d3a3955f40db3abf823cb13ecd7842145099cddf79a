I"Db<p>2018 年 3 月的时候我写过一篇在 Swift 中如何<a href="https://xiaozhuanlan.com/topic/6104325798">改进 Delegate Pattern</a> 的文章，主要思想是用遮蔽变量 (shadow variable) 声明的方式，来保证 <code class="highlighter-rouge">self</code> 变量可以被常时地标记为 <code class="highlighter-rouge">weak</code>。本文中，为了保证没有看过原文的读者能处在同一频道，我会先 (再次) 简单介绍一下这种方法。然后，结合 Swift 5.2 的新特性提出一些小的改进方式。</p>

<h2 id="delegate">Delegate</h2>

<p>简单说，为了避免繁琐老式的 <code class="highlighter-rouge">protocol</code> 定义和实现，我们可能更倾向于选择提供闭包的方式完成回调。比如在一个收集用户输入的自定义 view 中，提供一个外部可以设置的函数类型变量 <code class="highlighter-rouge">onConfirmInput</code>，并在合适的时候调用它：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">TextInputView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">inputTextField</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="k">var</span> <span class="nv">onConfirmInput</span><span class="p">:</span> <span class="p">((</span><span class="kt">String</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span>

    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">confirmButtonPressed</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">Any</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">onConfirmInput</span><span class="p">?(</span><span class="n">inputTextField</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">TextInputView</code> 的 controller 中，检测 input 确定事件就不需要一堆 <code class="highlighter-rouge">textInputView.delegate = self</code> 和 <code class="highlighter-rouge">textInputView(_:didConfirmText:)</code> 之类 的麻烦事了，可以直接设置 <code class="highlighter-rouge">onConfirmInput</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">textLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">inputView</span> <span class="o">=</span> <span class="kt">TextInputView</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="cm">/*...*/</span><span class="p">)</span>
        <span class="n">inputView</span><span class="o">.</span><span class="n">onConfirmInput</span> <span class="o">=</span> <span class="p">{</span> <span class="n">text</span> <span class="k">in</span> 
            <span class="k">self</span><span class="o">.</span><span class="n">textLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
        <span class="p">}</span>
        <span class="n">view</span><span class="o">.</span><span class="nf">addSubview</span><span class="p">(</span><span class="n">inputView</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是这引入了一个 retain cycle！<code class="highlighter-rouge">TextInputView.onConfirmInput</code> 持有 <code class="highlighter-rouge">self</code>，而 <code class="highlighter-rouge">self</code> 通过 <code class="highlighter-rouge">view</code> 持有 <code class="highlighter-rouge">TextInputView</code> 这个 sub view，内存将会无法释放。</p>

<p>当然，解决方法也很简单，我们只需要在设置 <code class="highlighter-rouge">onConfirmInput</code> 的时候使用 <code class="highlighter-rouge">[weak self]</code> 来将闭包中的 <code class="highlighter-rouge">self</code> 换为弱引用即可：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inputView</span><span class="o">.</span><span class="n">onConfirmInput</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">text</span> <span class="k">in</span>
    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">textLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这为使用 <code class="highlighter-rouge">onConfirmInput</code> 这样的闭包变量加上了一个前提：你大概率需要将 <code class="highlighter-rouge">self</code> 标记为 <code class="highlighter-rouge">weak</code> 以避免犯错，否则你将写出一个内存泄漏。这个泄漏无法在编译期间定位，运行时也不会有任何警告或者错误，这类问题也极易带到最终产品中。在开发界有一句话是真理：</p>

<blockquote>
  <p>如果一个问题可能发生，那么它必然会发生。</p>
</blockquote>

<p>一个简单的 <code class="highlighter-rouge">Delegate</code> 类型可以解决这个问题：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Delegate</span><span class="o">&lt;</span><span class="kt">Input</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">block</span><span class="p">:</span> <span class="p">((</span><span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span><span class="p">?)?</span>
    <span class="kd">func</span> <span class="n">delegate</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="o">&gt;</span><span class="p">(</span><span class="n">on</span> <span class="nv">target</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span> <span class="nv">block</span><span class="p">:</span> <span class="p">((</span><span class="kt">T</span><span class="p">,</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span><span class="p">)?)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="n">target</span><span class="p">]</span> <span class="n">input</span> <span class="k">in</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">target</span> <span class="o">=</span> <span class="n">target</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
            <span class="k">return</span> <span class="nf">block</span><span class="p">?(</span><span class="n">target</span><span class="p">,</span> <span class="n">input</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">call</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">block</span><span class="p">?(</span><span class="n">input</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>通过设置 <code class="highlighter-rouge">block</code> 时就将 <code class="highlighter-rouge">target</code> (通常是 <code class="highlighter-rouge">self</code>) 做 <code class="highlighter-rouge">weak</code> 化处理，并且在调用 <code class="highlighter-rouge">block</code> 时提供一个 weak 后的 <code class="highlighter-rouge">target</code> 的变量，就可以保证在调用侧不会意外地持有 <code class="highlighter-rouge">target</code>。举个例子，上面的 <code class="highlighter-rouge">TextInputView</code> 可以重写为：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">TextInputView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">let</span> <span class="nv">onConfirmInput</span> <span class="o">=</span> <span class="kt">Delegate</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">?,</span> <span class="kt">Void</span><span class="o">&gt;</span><span class="p">()</span>
    
    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">confirmButtonPressed</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">Any</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">onConfirmInput</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">inputTextField</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用时，通过 <code class="highlighter-rouge">delegate(on:)</code> 完成订阅：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inputView</span><span class="o">.</span><span class="n">onConfirmInput</span><span class="o">.</span><span class="nf">delegate</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="n">textLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
<span class="p">}</span>
</code></pre></div></div>

<p>闭包的输入参数 <code class="highlighter-rouge">(self, text)</code> 和闭包 body <code class="highlighter-rouge">self.textLabel.text</code> 中的 <code class="highlighter-rouge">self</code>，<strong>并不是</strong>原来的代表 controller 的 self，而是由 <code class="highlighter-rouge">Delegate</code> 把 <code class="highlighter-rouge">self</code> 标为 <code class="highlighter-rouge">weak</code> 后的参数。因此，直接在闭包中使用这个遮蔽变量 <code class="highlighter-rouge">self</code>，也不会造成循环引用。</p>

<p>到这里为止的原始版本 <code class="highlighter-rouge">Delegate</code> 可以在<a href="https://gist.github.com/onevcat/3c8f7c4e8c96f288854688cf34111636/3674c944a420a09f473726043856f28c9c1014d0">这个 Gist</a> 里找到，加上空行一共就 21 行代码。</p>

<h2 id="问题和改进">问题和改进</h2>

<p>上面的实现有三个小瑕疵，我们对它们进行一些分析和改进。</p>

<h3 id="1-更自然i的调用">1. 更自然i的调用</h3>

<p>现在，对 delegate 的调用时不如闭包变量那样自然，每次需要去使用 <code class="highlighter-rouge">call(_:)</code> 或者 <code class="highlighter-rouge">call()</code>。虽然不是什么大不了的事情，但是如果能直接使用类似 <code class="highlighter-rouge">onConfirmInput(inputTextField.text)</code> 的形式，会更简单。</p>

<p>Swift 5.2 中引入的 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0253-callable.md"><code class="highlighter-rouge">callAsFunction</code></a>，它可以让我们直接以“调用实例”的方式 call 一个方法。使用起来很简单，只需要创建一个名称为 <code class="highlighter-rouge">callAsFunction</code> 的实例方法就可以了：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Adder</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="kd">func</span> <span class="nf">callAsFunction</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">input</span> <span class="o">+</span> <span class="n">value</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">add2</span> <span class="o">=</span> <span class="kt">Adder</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="nf">add2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// 3</span>
</code></pre></div></div>

<p>这个特性非常适合把 <code class="highlighter-rouge">Delegate.call</code> 简化，只需要加入对应的 <code class="highlighter-rouge">callAsFunction</code> 实现，并调用 <code class="highlighter-rouge">block</code> 就行了：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">Delegate</span><span class="o">&lt;</span><span class="kt">Input</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    
    <span class="kd">func</span> <span class="nf">callAsFunction</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">block</span><span class="p">?(</span><span class="n">input</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">TextInputView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">confirmButtonPressed</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">Any</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">onConfirmInput</span><span class="p">(</span><span class="n">inputTextField</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在，<code class="highlighter-rouge">onConfirmInput</code> 的调用看起来就和一个闭包完全一样了。</p>

<blockquote>
  <p>类似于 <code class="highlighter-rouge">callAsFunction</code> 的直接在实例上调用方法的方式，在 Python 中有很多应用。在 Swift 语言中添加这个特性能让习惯于 Python 的开发者更容易地迁移到像是 Swift for TensorFlow 这样的项目。而这个提案的提出和审核相关人员，也基本是 Swift for TensorFlow 的成员。</p>
</blockquote>

<h3 id="2-双层可选值">2. 双层可选值</h3>

<p>如果 <code class="highlighter-rouge">Delegate&lt;Input, Output&gt;</code> 中的 <code class="highlighter-rouge">Output</code> 是一个可选值的话，那么 <code class="highlighter-rouge">call</code> 之后的结果将会是双重可选的 <code class="highlighter-rouge">Output??</code>。</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">onReturnOptional</span> <span class="o">=</span> <span class="kt">Delegate</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">?</span><span class="o">&gt;</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="n">onReturnOptional</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// value : Int??</span>
</code></pre></div></div>

<p>这可以让我们区分出 <code class="highlighter-rouge">block</code> 没有被设置的情况和 <code class="highlighter-rouge">Delegate</code> 确实返回 <code class="highlighter-rouge">nil</code> 的情况：当 <code class="highlighter-rouge">onReturnOptional.delegate(on:block:)</code> 没有被调用过 (<code class="highlighter-rouge">block</code> 为 <code class="highlighter-rouge">nil</code>) 时，<code class="highlighter-rouge">value</code> 是简单的 <code class="highlighter-rouge">nil</code>。但如果 <code class="highlighter-rouge">delegate</code> 被设置了，但是闭包返回的是 <code class="highlighter-rouge">nil</code> 时，<code class="highlighter-rouge">value</code> 的值将为 <code class="highlighter-rouge">.some(nil)</code>。在实际使用上这很容易造成困惑，绝大多数情况下，我们希望把 <code class="highlighter-rouge">.none</code>，<code class="highlighter-rouge">.some(.none)</code> 和 <code class="highlighter-rouge">.some(.some(value))</code> 这样的返回值展平到单层 <code class="highlighter-rouge">Optional</code> 的 <code class="highlighter-rouge">.none</code> 或 <code class="highlighter-rouge">.some(value)</code>。</p>

<p>要解决这个问题，可以对 <code class="highlighter-rouge">Delegate</code> 进行扩展，为那些 <code class="highlighter-rouge">Output</code> 是 <code class="highlighter-rouge">Optional</code> 情况提供重载的 <code class="highlighter-rouge">call(_:)</code> 实现。不过 <code class="highlighter-rouge">Optional</code> 是带有泛型参数的类型，所以我们没有办法写出像是 
<code class="highlighter-rouge">extension Delegate where Output == Optional</code> 这样的条件扩展。一个“取巧”的方式是自定义一个新的 <code class="highlighter-rouge">OptionalProtocol</code>，让 <code class="highlighter-rouge">extension</code> 基于 <code class="highlighter-rouge">where Output: OptionalProtocol</code> 来做条件扩展：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">OptionalProtocol</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">var</span> <span class="nv">createNil</span><span class="p">:</span> <span class="k">Self</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Optional</span> <span class="p">:</span> <span class="kt">OptionalProtocol</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">var</span> <span class="nv">createNil</span><span class="p">:</span> <span class="kt">Optional</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span> <span class="p">{</span>
         <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Delegate</span> <span class="k">where</span> <span class="kt">Output</span><span class="p">:</span> <span class="kt">OptionalProtocol</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">call</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="nf">block</span><span class="p">?(</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">.</span><span class="n">createNil</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样，即使 <code class="highlighter-rouge">Output</code> 为可选值，<code class="highlighter-rouge">block?(input)</code> 调用所得到的结果也可以经过 <code class="highlighter-rouge">if let</code> 解包，并返回单层的 <code class="highlighter-rouge">result</code> 或是 <code class="highlighter-rouge">nil</code>。</p>

<h3 id="3-遮蔽失效">3. 遮蔽失效</h3>

<p>由于使用了遮蔽变量 <code class="highlighter-rouge">self</code>，在闭包中的 <code class="highlighter-rouge">self</code> 其实是这个遮蔽变量，而非原本的 <code class="highlighter-rouge">self</code>。这样要求我们比较小心，否则可能造成意外的循环引用。比如下面的例子：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inputView</span><span class="o">.</span><span class="n">onConfirmInput</span><span class="o">.</span><span class="nf">delegate</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="n">textLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的代码编译和使用都没有问题，但是由于我们把 <code class="highlighter-rouge">(self, text)</code> 换成了 <code class="highlighter-rouge">(_, text)</code>，这导致闭包内部 <code class="highlighter-rouge">self.textLabel.text</code> 中的 <code class="highlighter-rouge">self</code> 直接参照了真正的 <code class="highlighter-rouge">self</code>，这是一个强引用，进而内存泄露。</p>

<p>这种错误和 <code class="highlighter-rouge">[weak self]</code> 声明一样，没有办法得到编译器的提示，所以也很难完全避免。也许一个可行方案是不要用 <code class="highlighter-rouge">(self, text)</code> 这样的隐式遮蔽，而是将参数名明确写成不一样的形式，比如 <code class="highlighter-rouge">(weakSelf, text)</code>，然后在闭包中只使用 <code class="highlighter-rouge">weakSelf</code>。但这么做其实和 <code class="highlighter-rouge">self</code> 遮蔽差距不大，依然摆脱不了用“人为规定”来强制统一代码规则。当然，你也可以依靠使用 linter 和添加对应规则来提醒自己，但是这些方式也都不是非常理想。如果你有什么好的想法或者建议，十分欢迎交流和指教。</p>
:ET