I"-<h2 id="性能优化">性能优化</h2>
<h4 id="卡顿优化">卡顿优化</h4>
<ul>
  <li>CPU
    <ul>
      <li>CPU（Central Processing Unit，中央处理器）</li>
      <li>对象的创建和销毁</li>
      <li>对象属性的调</li>
      <li>布局计算</li>
      <li>文本的计算和排版</li>
      <li>图片的格式转换和解码</li>
      <li>图像的绘制（Core Graphics</li>
    </ul>
  </li>
  <li>GPU
    <ul>
      <li>GPU（Graphics Processing Unit，图形处理器）</li>
      <li>纹理的渲染</li>
    </ul>
  </li>
  <li>屏幕成像原理
    <ul>
      <li><img src="/media/15372805769589/15372807658977.jpg" alt="" /></li>
    </ul>
  </li>
  <li>卡顿产生的原因
    <ul>
      <li><img src="/media/15372805769589/15372807967880.jpg" alt="" />
        <ul>
          <li>CPU 和 GPU 在绘制一帧的时间内,垂直同步信号（VSync), 开始水平同步信号（HSync)绘制画面,如果在,垂直同步信号之前没有CPU + GPU 没有完成工作,那么产生丢帧,显示上一帧的画面,从而导致卡顿.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>卡顿优化 - CPU
    <ul>
      <li>尽量用轻量级的对象(比如显示数值,NSnumber 和 Int)，比如用不到事件处理的地方，可以考虑使用CALayer取代UIView</li>
      <li>不要频繁地调用UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改</li>
      <li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li>
      <li>
        <p>Autolayout会比直接设置frame消耗更多的CPU资源</p>
      </li>
      <li>
        <p>图片的size最好刚好跟UIImageView的size保持一致</p>
      </li>
      <li>控制一下线程的最大并发数量</li>
      <li>尽量把耗时的操作放到子线程
        <ul>
          <li>文本处理（尺寸计算、绘制）</li>
          <li>图片处理（解码、绘制）self.imagView.image = [UIImage imageWith@”xxx”],拿到后的图片是压缩后的图片,默认在主线程执行,所以需要异步绘制,1&gt; 得到CGImage, 2&gt; 创建上下文 3&gt; 使用CGCongtexDrawImage 画出来, 4&gt; 得到图片 5&gt; 包装Image</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>卡顿优化 - GPU</p>

    <ul>
      <li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li>
      <li>GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</li>
      <li>减少透明的视图（alpha&lt;1），不透明的就设置opaque为YES</li>
      <li>尽量避免出现离屏渲染</li>
    </ul>
  </li>
  <li>离屏渲染
    <ul>
      <li>在OpenGL中，GPU有2种渲染方式
        <ul>
          <li>On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作</li>
          <li>Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作</li>
        </ul>
      </li>
      <li>离屏渲染消耗性能的原因
        <ul>
          <li>需要创建新的缓冲区</li>
          <li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕</li>
          <li>哪些操作会触发离屏渲染？
            <ul>
              <li>光栅化，layer.shouldRasterize = YES</li>
              <li>遮罩，layer.mask</li>
              <li>圆角，同时设置layer.masksToBounds = YES、layer.cornerRadius大于0(考虑通过CoreGraphics绘制裁剪圆角，或者叫美工提供圆角图片)</li>
              <li>阴影，layer.shadowXXX(如果设置了layer.shadowPath就不会产生离屏渲染)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>卡顿检测
    <ul>
      <li>平时所说的“卡顿”主要是因为在主线程执行了比较耗时的操作</li>
      <li>可以添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的</li>
    </ul>
  </li>
</ul>

<h4 id="耗电优化">耗电优化</h4>
<ul>
  <li>耗电的主要来源
    <ul>
      <li>CPU处理，Processing</li>
      <li>网络，Networking</li>
      <li>定位，Location</li>
      <li>图像，Graphics</li>
    </ul>
  </li>
  <li>耗电cpu层面
    <ul>
      <li>尽可能降低CPU、GPU功耗,(在不同的网络条件下合理分配最大并发数量)</li>
      <li>少用定时器</li>
      <li>优化I/O操作
        <ul>
          <li>尽量不要频繁写入小数据，最好批量一次性写入</li>
          <li>读写大量重要数据时，考虑用dispatch_io，其提供了基于GCD的异步操作文件I/O的API。用dispatch_io系统会优化磁盘访问</li>
          <li>数据量比较大的，建议使用数据库（比如SQLite、CoreData）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>耗电网络优化层面
    <ul>
      <li>减少、压缩网络数据</li>
      <li>如果多次请求的结果是相同的，尽量使用缓存.https://www.cnblogs.com/MJP334414/p/5893670.html</li>
      <li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li>
      <li>网络不可用时，不要尝试执行网络请求</li>
      <li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间(左上角的Nav不要遮盖)</li>
      <li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果下载广告，一次性多下载一些，然后再慢慢展示。如果下载电子邮件，一次下载多封，不要一封一封地下载</li>
    </ul>
  </li>
  <li>耗电定位层面
    <ul>
      <li>如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电, 尽量不要使用requestAlwaysAuthorization, https://www.jianshu.com/p/ef6994767cbb</li>
      <li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li>
      <li>尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest</li>
      <li>需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新</li>
      <li>尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion:</li>
    </ul>
  </li>
  <li>硬件检测优化
    <ul>
      <li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li>
    </ul>
  </li>
</ul>

<h4 id="app的启动">APP的启动</h4>
<ul>
  <li>APP的启动可以分为2种
    <ul>
      <li>冷启动（Cold Launch）：从零开始启动APP</li>
      <li>热启动（Warm Launch）：APP已经在内存中，在后台存活着，再次点击图标启动APP</li>
    </ul>
  </li>
  <li>APP启动时间的优化，主要是针对冷启动进行优化</li>
  <li>通过添加环境变量可以打印出APP的启动时间分析（Edit scheme -&gt; Run -&gt; Arguments）
    <ul>
      <li>DYLD_PRINT_STATISTICS设置为1</li>
      <li>如果需要更详细的信息，那就将DYLD_PRINT_STATISTICS_DETAILS设置为1</li>
    </ul>
  </li>
  <li>APP的冷启动可以概括为3大阶段
    <ul>
      <li>dyld</li>
      <li>runtime</li>
      <li>main</li>
    </ul>
  </li>
  <li>APP的启动 - dyld（dynamic link editor），Apple的动态链接器，可以用来装载Mach-O文件（可执行文件、动态库等）
    <ul>
      <li>启动APP时，dyld所做的事情有</li>
      <li>装载APP的可执行文件，同时会递归加载所有依赖的动态库</li>
      <li>当dyld把可执行文件、动态库都装载完毕后，会通知Runtime进行下一步的处理</li>
    </ul>
  </li>
  <li>APP的启动 - runtime
    <ul>
      <li>启动APP时，runtime所做的事情有</li>
      <li>
        <p>调用map_images进行可执行文件内容的解析和处理</p>
      </li>
      <li>进行各种objc结构的初始化（注册Objc类 、初始化类对象等等</li>
      <li>在load_images中调用call_load_methods，调用所有Class和Category的+load方法</li>
      <li>调用C++静态初始化器和__attribute__((constructor))修饰的函数</li>
      <li><strong>到此为止，可执行文件和动态库中所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被runtime 所管理</strong></li>
    </ul>
  </li>
  <li>APP的启动 - main
    <ul>
      <li>接下来就是UIApplicationMain函数，AppDelegate的application:didFinishLaunchingWithOptions:方法</li>
    </ul>
  </li>
  <li>冷启动 - 总结一下
    <ul>
      <li>APP的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库</li>
      <li>并由runtime负责加载成objc定义的结构</li>
      <li>所有初始化工作结束后，dyld就会调用main函数</li>
      <li>接下来就是UIApplicationMain函数，AppDelegate的application:didFinishLaunchingWithOptions:方法</li>
    </ul>
  </li>
  <li>APP的启动优化
    <ul>
      <li>按照不同的阶段
        <ul>
          <li>dyld
            <ul>
              <li>减少动态库、合并一些动态库（定期清理不必要的动态库）</li>
              <li>减少Objc类、分类的数量、减少Selector数量（定期清理不必要的类、分类）</li>
              <li>减少C++虚函数数量</li>
              <li>Swift尽量使用struct</li>
            </ul>
          </li>
          <li>runtime
            <ul>
              <li>用+initialize方法和dispatch_once取代所有的__attribute__((constructor))、C++静态构造器、ObjC的+load</li>
            </ul>
          </li>
          <li>main
            <ul>
              <li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在finishLaunching方法中</li>
              <li>按需加载</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="安装包瘦身">安装包瘦身</h4>
<ul>
  <li>安装包（IPA）主要由可执行文件、资源组成</li>
  <li>资源（图片、音频、视频等）
    <ul>
      <li>采取无损压缩</li>
      <li>去除没有用到的资源： https://github.com/tinymind/LSUnusedResources</li>
    </ul>
  </li>
  <li>可执行文件瘦身
    <ul>
      <li>编译器优化
        <ul>
          <li>Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES(新版已经提供)</li>
          <li>去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO， Other C Flags添加-fno-exceptions</li>
        </ul>
      </li>
      <li>利用AppCode（https://www.jetbrains.com/objc/）检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code</li>
      <li>编写LLVM插件检测出重复代码、未被调用的代码</li>
      <li>借助第三方解析工具文件的具体组成<a href="https://github.com/huanxsd/LinkMap">LinkMap</a></li>
    </ul>
  </li>
</ul>

:ET